\documentclass[cn,11pt,chinese]{elegantbook}

\usepackage{diagbox}
\usepackage{minted}
\usepackage{minted,tabularx,tikz}
\usepackage{graphicx}
\usetikzlibrary{
  shapes,
  shapes.geometric,
  decorations.text,
  shapes.geometric,
  calc,
  decorations.pathreplacing,
  automata,
  positioning,
  arrows
}

\usepackage{tcolorbox}
\tcbuselibrary{skins, breakable, theorems}

\setcounter{tocdepth}{2}

\title{尚硅谷Flink教程}

% 本文档命令
\usepackage{array}
\newcommand{\ccr}[1]{\makecell{{\color{#1}\rule{1cm}{1cm}}}}

\begin{document}

\pagestyle{empty}

\begin{tikzpicture}[remember picture,overlay]
%%%%%%%%%%%%%%%%%%%% Background %%%%%%%%%%%%%%%%%%%%%%%%
\fill[Dandelion] (current page.south west) rectangle (current page.north east);




%%%%%%%%%%%%%%%%%%%% Background Polygon %%%%%%%%%%%%%%%%%%%%

\foreach \i in {2.5,...,22}
{
    \node[rounded corners,Dandelion!60,draw,regular polygon,regular polygon sides=6, minimum size=\i cm,ultra thick] at ($(current page.west)+(2.5,-5)$) {} ;
}

\foreach \i in {0.5,...,22}
{
\node[rounded corners,Dandelion!60,draw,regular polygon,regular polygon sides=6, minimum size=\i cm,ultra thick] at ($(current page.north west)+(2.5,0)$) {} ;
}

\foreach \i in {0.5,...,22}
{
\node[rounded corners,Dandelion!90,draw,regular polygon,regular polygon sides=6, minimum size=\i cm,ultra thick] at ($(current page.north east)+(0,-9.5)$) {} ;
}


\foreach \i in {21,...,6}
{
\node[Dandelion!85,rounded corners,draw,regular polygon,regular polygon sides=6, minimum size=\i cm,ultra thick] at ($(current page.south east)+(-0.2,-0.45)$) {} ;
}


%%%%%%%%%%%%%%%%%%%% Title of the Report %%%%%%%%%%%%%%%%%%%% 
\node[left,black,minimum width=0.625*\paperwidth,minimum height=3cm, rounded corners] at ($(current page.north east)+(0,-9.5)$)
{
{\fontsize{25}{30} \selectfont \bfseries 编译器和编程语言设计导论}
};

%%%%%%%%%%%%%%%%%%%% Subtitle %%%%%%%%%%%%%%%%%%%% 
\node[left,black,minimum width=0.625*\paperwidth,minimum height=2cm, rounded corners] at ($(current page.north east)+(0,-11)$)
{
{\huge \textit{Introduction to Compilers and Language Design}}
};

%%%%%%%%%%%%%%%%%%%% Author Name %%%%%%%%%%%%%%%%%%%% 
\node[left,black,minimum width=0.625*\paperwidth,minimum height=2cm, rounded corners] at ($(current page.north east)+(0,-13)$)
{
{\Large \textsc{左元 \; 译}}
};

%%%%%%%%%%%%%%%%%%%% Year %%%%%%%%%%%%%%%%%%%% 
\node[rounded corners,fill=Dandelion!70,text =black,regular polygon,regular polygon sides=6, minimum size=2.5 cm,inner sep=0,ultra thick] at ($(current page.west)+(2.5,-5)$) {\LARGE \bfseries 2022};

\end{tikzpicture}

\frontmatter

\tableofcontents
%\listofchanges

\mainmatter

\chapter{简介}

\section{什么是编译器？}

\section{为什么要学习编译器？}

\section{学习编译器的最佳实践是什么？}

\section{应该使用什么语言实现编译器？}

\section{这本书和其它编译器课本的区别是什么？}

\section{我需要阅读哪些其他编译器课本？}

\chapter{快速指南}

\section{编译器工具链}

\section{C编译器的各个阶段}

\section{编译举例}

\section{练习}

\chapter{词法分析}

\section{标记的类型}

\section{一个手工词法分析器}

\section{正则表达式}

\section{有限自动机}

\subsection{确定性有限自动机}

\subsection{非确定性有限自动机}

\section{转换算法}

\subsection{将RE转换成NFA}

\subsection{将NFA转换成DFA}

\subsection{最小化DFA}

\section{有限自动机的局限性}

\section{词法分析器生成器的使用}

\section{实践上的考虑}

\section{练习}

\section{深入阅读}

\chapter{语法分析}

\section{概述}

\section{上下无关文法}

\subsection{文法推导}

\subsection{有歧义的文法}

\section{LL语法}

\subsection{消除左递归}

\subsection{消除最左公共前缀}

\subsection{First集合和Follow集合}

\subsection{递归下降语法分析}

\subsection{表驱动语法分析}

\section{LR语法}

\subsection{移进-归约语法分析}

\subsection{LR(0)自动化}

\subsection{SLR语法分析}

\subsection{LR(1)语法分析}

\subsection{LALR语法分析}

\section{语法分类重探}

\section{乔姆斯基文法等级体系}

\section{练习}

\section{深入阅读}

\chapter{实践中的语法分析}

\section{Bison语法分析器生成器}

\section{表达式校验器}

\section{表达式解释器}

\section{表达式树}

\section{练习}

\section{深入阅读}

\chapter{抽象语法树}

\section{概览}

\section{声明}

\section{语句}

\section{表达式}

\section{类型}

\section{将以上内容结合在一起}

\section{构建AST}

\section{练习}

\chapter{语义分析}

\section{类型系统概述}

\section{类型系统的设计}

\section{B-Minor的类型系统}

\section{符号表}

\section{名字的解析}

\section{类型检查的实现}

\section{错误信息}

\section{练习}

\section{深入阅读}

\chapter{中间表示}

\section{简介}

\section{抽象语法树}

\section{有向无环图}

\section{控制流图}

\section{静态单赋值形式}

\section{线性IR}

\section{栈机器IR}

\section{IR举例}

\subsection{GIMPLE-GNU Simple Representation}

\subsection{LLVM-Low Level Virtual Machine}

\subsection{JVM-Java Virtual Machine}

\section{练习}

\section{深入阅读}

\chapter{内存组成}

\section{简介}

\section{逻辑分区}

\section{堆的管理}

\section{栈的管理}

\subsection{栈调用约定}

\subsection{寄存器调用约定}

\section{数据的定位}

\section{程序的加载}

\section{深入阅读}

\chapter{汇编语言}

\section{简介}

\section{开源汇编工具}

\section{X86汇编语言}

\subsection{寄存器和数据类型}

\subsection{寻址模式}

\subsection{基本算术}

\subsection{比较和跳转}

\subsection{栈}

\subsection{函数调用}

\subsection{叶子函数的定义}

\subsection{复杂函数的定义}

\section{ARM汇编语言}

\subsection{寄存器和数据类型}

\subsection{寻址模式}

\subsection{基本算术}

\subsection{比较和分支}

\subsection{栈}

\subsection{函数调用}

\subsection{叶子函数的定义}

\subsection{复杂函数的定义}

\subsection{64位的不同之处}

\section{深入阅读}

\chapter{代码生成}

\section{简介}

\section{函数的代码生成}

\section{表达式的代码生成}

\section{语句的代码生成}

\section{条件表达式的代码生成}

\section{声明的代码生成}

\section{练习}

\chapter{优化}

\section{概览}

\section{优化的思路}

\section{高层优化}

\subsection{常量折叠}

\subsection{强度削减}

\subsection{循环展开}

\subsection{代码提升}

\subsection{函数内联}

\subsection{死代码检测和删除}

\section{底层优化}

\subsection{窥孔优化}

\subsection{指令选择}

\section{寄存器分配}

\subsection{寄存器分配的安全性}

\subsection{寄存器分配的优先级}

\subsection{变量之间的冲突}

\subsection{全局寄存器分配}

\section{优化的陷阱}

\section{优化的相互影响}

\section{练习}

\section{深入阅读}


\end{document}