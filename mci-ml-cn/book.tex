\documentclass[cn,11pt,chinese]{elegantbook}

\usepackage{amsmath,environ}
\usepackage{epigraph}
\usepackage{marginnote}
\usepackage[newfloat]{minted}
\usepackage{caption}
\usepackage{tcolorbox}
\usepackage{diagbox}
\usepackage{tabularx,tikz}
\usepackage{graphicx}
\usepackage{mathtools}
\usemintedstyle{xcode}
\usetikzlibrary{
  shapes,
  decorations.text,
  shapes.geometric,
  shapes.multipart,
  chains,
  calc,
  decorations.pathreplacing,
  automata,
  positioning,
  arrows
}

\newenvironment{code}{\captionsetup{type=listing}}{}
\SetupFloatingEnvironment{listing}{name=程序}

\tcbuselibrary{skins, breakable, theorems}

\setcounter{tocdepth}{2}

\title{现代编译原理}

% 本文档命令
\usepackage{array}
\newcommand{\ccr}[1]{\makecell{{\color{#1}\rule{1cm}{1cm}}}}

\DeclareMathSymbol{"}{\mathalpha}{letters}{`"}
\begin{document}

\thispagestyle{empty}

\begin{tikzpicture}[remember picture,overlay]
%%%%%%%%%%%%%%%%%%%% Background %%%%%%%%%%%%%%%%%%%%%%%%
\fill[Dandelion] (current page.south west) rectangle (current page.north east);




%%%%%%%%%%%%%%%%%%%% Background Polygon %%%%%%%%%%%%%%%%%%%%

\foreach \i in {2.5,...,22}
{
    \node[rounded corners,Dandelion!60,draw,regular polygon,regular polygon sides=6, minimum size=\i cm,ultra thick] at ($(current page.west)+(2.5,-5)$) {} ;
}

\foreach \i in {0.5,...,22}
{
\node[rounded corners,Dandelion!60,draw,regular polygon,regular polygon sides=6, minimum size=\i cm,ultra thick] at ($(current page.north west)+(2.5,0)$) {} ;
}

\foreach \i in {0.5,...,22}
{
\node[rounded corners,Dandelion!90,draw,regular polygon,regular polygon sides=6, minimum size=\i cm,ultra thick] at ($(current page.north east)+(0,-9.5)$) {} ;
}


\foreach \i in {21,...,6}
{
\node[Dandelion!85,rounded corners,draw,regular polygon,regular polygon sides=6, minimum size=\i cm,ultra thick] at ($(current page.south east)+(-0.2,-0.45)$) {} ;
}


%%%%%%%%%%%%%%%%%%%% Title of the Report %%%%%%%%%%%%%%%%%%%% 
\node[left,black,minimum width=0.625*\paperwidth,minimum height=3cm, rounded corners] at ($(current page.north east)+(0,-9.5)$)
{
{\fontsize{25}{30} \selectfont \bfseries 现代编译原理}
};

%%%%%%%%%%%%%%%%%%%% Subtitle %%%%%%%%%%%%%%%%%%%% 
\node[left,black,minimum width=0.625*\paperwidth,minimum height=2cm, rounded corners] at ($(current page.north east)+(0,-11)$)
{
{\huge \textit{ML语言描述}}
};

%%%%%%%%%%%%%%%%%%%% Author Name %%%%%%%%%%%%%%%%%%%% 
\node[left,black,minimum width=0.625*\paperwidth,minimum height=2cm, rounded corners] at ($(current page.north east)+(0,-13)$)
{
{\Large \textsc{[美] Andrew W.Appel \; Maia Ginsburg 著}}
};

%%%%%%%%%%%%%%%%%%%% Year %%%%%%%%%%%%%%%%%%%% 
\node[rounded corners,fill=Dandelion!70,text =black,regular polygon,regular polygon sides=6, minimum size=2.5 cm,inner sep=0,ultra thick] at ($(current page.west)+(2.5,-5)$) {\LARGE \bfseries 2022};

\end{tikzpicture}

\frontmatter

\tableofcontents
%\listofchanges

\mainmatter


\chapter*{前言}

近十余年来，编译器的构建方法出现了一些新的变化。一些新的程序设计语言得到应用，例如，具有动态方法的面向对象语言、具有嵌套作用域和一等函数闭包（first-class function closure）的函数式语言等。这些语言中有许多都需要垃圾收集技术的支持。另一方面，新的计算机都有较大的寄存器集合，且存储器访问成为了影响性能的主要因素。这类机器在具有指令调度能力并能对指令和数据高速缓存（cache）进行局部性优化的编译器辅助下，常常能运行得更快。

本书可作为一到两个学期编译课程的教材。学生将看到编译器不同部分中隐含的理论，学习到将这些理论付诸实现时使用的程序设计技术和以模块化方式实现该编译器时使用的接口。为了清晰具体地给出这些接口和程序设计的例子，我使用ML语言来编写它们。本（序列）书还有使用C和Java语言的另外两种版本。

\textbf{实现项目}。我在书中概述了一个“学生项目编译器”，它相当简单，而且其安排方式也便于说明现在常用的一些重要技术。这些技术包括避免语法和语义相互纠缠的抽象语法树，独立于寄存器分配的指令选择，能使编译器前期阶段有更多灵活性的复写传播，以及防止从属于特定目标机的方法。与其他许多教材中的“学生编译器”不同，本书中采用的编译器有一个简单而完整的后端，它允许在指令选择之后进行寄存器分配。

本书第一部分中，每一章都有一个与编译器的某个模块对应的程序设计习题。在

\href{http://www.cs.princeton.edu/\textasciitilde appel/modern/ml}{http://www.cs.princeton.edu/\textasciitilde appel/modern/ml}

中可找到对这些习题有帮助的一些软件。

\textbf{习题}。每一章都有一些书面习题：标有一个星号的习题有点挑战性，标有两个星号的习题较难但仍可解决，偶尔出现的标有三个星号的习题是一些尚未找到解决方法的问题。

\textbf{授课顺序}。图\ref{fig:0-1}展示了各章相互之间的依赖关系。

\begin{figure}[htbp]
	\centering
	\scalebox{.6}{
	\begin{tikzpicture}
		\node[rectangle,text width=2cm,align=center,text width=2cm,align=center] (1) {第1章 \\ 绪论};
		\node[rectangle,text width=2cm,align=center,above right = of 1] (6) {第6章 \\ 活动记录};
		\node[rectangle,text width=2cm,align=center,above = of 6] (2) {第2章 \\ 词法分析};
		\node[rectangle,text width=2cm,align=center,right = of 2] (3) {第3章 \\ 语法分析};
		\node[rectangle,text width=2cm,align=center,right = of 3] (4) {第4章 \\ 抽象语法};
		\node[rectangle,text width=2cm,align=center,right = of 4] (5) {第5章 \\ 语义分析};
		\node[rectangle,text width=3cm,align=center,right = of 6] (7) {第7章 \\ 翻译成中间代码};
		\node[rectangle,text width=3cm,align=center,right = of 7] (8) {第8章 \\ 基本块和轨迹};
		\node[rectangle,text width=2cm,align=center,right = of 1] (9) {第9章 \\ 指令选择};
		\node[rectangle,text width=2cm,align=center,below right = of 1] (10) {第10章 \\ 活跃分析};
		\node[rectangle,text width=3cm,align=center,right = of 10] (11) {第11章 \\ 寄存器分配};
		\node[rectangle,text width=2cm,align=center,below right = of 8] (12) {第12章 \\ 整合为一体};
		\node[rectangle,text width=3cm,align=center,below right = of 10] (17) {第17章 \\ 数据流分析};
		\node[rectangle,text width=2cm,align=center,right = of 17] (18) {第18章 \\ 循环优化};
		\node[rectangle,text width=4cm,align=center,below left = of 17] (15) {第15章 \\ 函数式程序设计语言};
		\node[rectangle,text width=2cm,align=center,right = of 15] (16) {第16章 \\ 多态类型};
		\node[rectangle,text width=2cm,align=center,below = of 15] (13) {第13章 \\ 垃圾收集};
		\node[rectangle,text width=3cm,align=center,right = of 13] (14) {第14章 \\ 面向对象的语言};
		\node[rectangle,text width=3cm,align=center,right = of 18] (19) {第19章 \\ 静态单赋值形式};
		\node[rectangle,text width=3cm,align=center,below = of 19] (20) {第20章 \\ 流水和调度};
		\node[rectangle,text width=2cm,align=center,below = of 20] (21) {第21章 \\ 存储层次};

		\draw[thick] (1) -- (2) -- (3) -- (4) -- (5);
		\draw[thick] (1) -- (6) -- (7) -- (8) -- (12);
		\draw[thick] (1) -- (9) -- (12);
		\draw[thick] (1) -- (10) -- (11) -- (12);
		\draw[thick] (10) -- (17) -- (18) -- (19);
		\draw[thick] (15) -- (16);
		\draw[thick] (18) -- (20);
		\draw[thick] (18) -- (21);
		\draw[thick] (5) -- (7);

		\node[rectangle,right = of 5,yshift=-1.3cm,xshift=1cm] (22) {
			\begin{tikzpicture}
				\node[rectangle,text width=1cm,align=center] (1) {半 \\ 学 \\ 期};
				\node[rectangle,above = of 1,yshift=-0.2cm] (2) {};
				\node[rectangle,below = of 1,yshift=0.2cm] (3) {};
				\draw[thick,->] (1) -- (2);
				\draw[thick,->] (1) -- (3);
			\end{tikzpicture}
		};
		\node[rectangle,below = of 22,yshift=0.8cm] (23) {
			\begin{tikzpicture}
				\node[rectangle,text width=1cm,align=center] (1) {半 \\ 学 \\ 期};
				\node[rectangle,above = of 1,yshift=0.8cm] (2) {};
				\node[rectangle,below = of 1,yshift=-0.8cm] (3) {};
				\draw[thick,->] (1) -- (2);
				\draw[thick,->] (1) -- (3);
			\end{tikzpicture}
		};
		\node[rectangle,right = of 22,yshift=-2cm,xshift=-1cm] (24) {
			\begin{tikzpicture}
				\node[rectangle,text width=1cm,align=center] (1) {一 \\ 学 \\ 期};
				\node[rectangle,above = of 1,yshift=2cm] (2) {};
				\node[rectangle,below = of 1,yshift=-2.8cm] (3) {};
				\draw[thick,->] (1) -- (2);
				\draw[thick,->] (1) -- (3);
			\end{tikzpicture}
		};
		\node[rectangle,below = of 24,yshift=1cm] (25) {
			\begin{tikzpicture}
				\node[rectangle,text width=1cm,align=center] (1) {一 \\ 学 \\ 期};
				\node[rectangle,above = of 1,yshift=1.8cm] (2) {};
				\node[rectangle,below = of 1,yshift=-1.8cm] (3) {};
				\draw[thick,->] (1) -- (2);
				\draw[thick,->] (1) -- (3);
			\end{tikzpicture}
		};
	\end{tikzpicture}
	}
  \caption{内容结构图}
  \label{fig:0-1}
	\end{figure}

\begin{itemize}
  \item 一学期的课程可包含第一部分的所有章节（第1\textasciitilde 12章），同时让学生实现项目编译器（多半按项目组的方式进行）。另外，授课内容中还可以包含从第二部分中选择的一些主题。
  \item 高级课程或研究生课程可包含第二部分的内容，以及另外一些来自其他文献的主题。第二部分中有许多章节和第一部分无关，因此，对于那些在初始课程中使用不同教材的学生而言，仍然可以给他们讲授高级课程。
  \item 若按两个半个学期来安排教学，则前半学期可包含第1\textasciitilde 8章，后半学期包括第9\textasciitilde 12章和第二部分的某些章。
\end{itemize}

\textbf{致谢}。对于本书，许多人给我提出了富有建设性的意见，或在其他方面给我提供了帮助。我要感谢这些人，他们是Leonor Abraido-Fandino，Scott Ananian，Stephen Bailey，Maia Ginsburg，Max Hailperin，David Hanson，Jeffrey Hsu，David MacQueen，Torben Mogensen，Doug Morgan，Robert Netzer，Elma Lee Noah，Mikael Petterson，Todd Proebsting，Anne Rogers，Barbara Ryder，Amr Sabry，Mooly Sagiv，Zhong Shao，Mary Lou Soffa，Andrew Tolmach，Kwangkeun Yi和Kenneth Zadeck。

\part{编译基本原理}

\chapter{绪论}

\epigraph{\textbf{编译器}（compiler）：原指一种将各个子程序装配组合到一起的程序[连接-装配器]。当1954年出现了（确切地说是误用了）复合术语“代数编译器”（algebraic compiler）之后，这个术语的意思变成了现在的含义。}{Bauer和Eickel[1975]}

本书讲述将程序设计语言转换成可执行代码时使用的技术、数据结构和算法。现代编译器常常由多个阶段组成，每一阶段处理不同的抽象“语言”。本书的章节按照编译器的结构来组织，每一章循序渐进地论及编译器的一个阶段。

为了阐明编译真实的程序设计语言时遇到的问题，本书以Tiger语言为例来说明如何编译一种语言。Tiger语言是一种类Algol的语言，它有嵌套的作用域和在堆中分配存储空间的记录，虽简单却并不平凡。每一章的程序设计练习都要求实现相应的编译阶段；如果学生实现了本书第一部分讲述的所有阶段，便能够得到一个可以运行的编译器。将Tiger修改成\textit{函数式的}或\textit{面向对象的}（或同时满足两者的）语言并不难，第二部分中的习题说明了如何进行这种修改。第二部分的其他章节讨论了有关程序优化的高级技术。附录描述了Tiger语言。

编译器各模块之间的接口几乎和模块内部的算法同等重要。为了具体描述这些接口，较好的做法是用真正的程序设计语言来编写它们，本书使用的是ML语言——一种严格的，具有模块系统的，静态类型的函数式编程语言。ML语言适合用来编写很多类型的应用程序。但如果使用ML语言来实现编译器，似乎能最大限度的利用ML语言中的一些强大特性，同时无需使用ML语言的一些缺陷特性。使用ML语言来实现一个编译器，是一个很愉快的过程。而且，对于一本完备的编译器教材来讲，书中需要引入一些现代编程语言设计的教学内容。

\section{模块与接口}

对于任何大型软件系统，如果设计者注意到了该系统的基本抽象和接口，那么对这个系统的理解和实现就要容易得多。图\ref{fig:1-1}展示了一个典型的编译器的各个阶段，每个阶段由一至多个软件模块来实现。


\begin{figure}[htbp]
	\centering
	\scalebox{.4}{
	\begin{tikzpicture}[node distance=0.1cm]
		\node[rectangle,draw=black,text width=1cm,align=center,minimum height=2.5cm,minimum width=2.5cm] (1) {环境};
		\node[rectangle,below = of 1] (2) {表};
		\node[rectangle,draw=black,below = of 2,text width=1cm,align=center,minimum height=2.5cm,minimum width=2.5cm] (3) {语义\\分析};
		\node[rectangle,left = of 3,text width=0.5cm] (4) {抽象语法};
		\node[rectangle,right = of 3,text width=0.5cm] (5) {转换};
		\node[rectangle,draw=black,left = of 4,text width=1cm,align=center,minimum height=2.5cm,minimum width=2.5cm] (6) {语义\\动作};
		\node[rectangle,draw=black,right = of 5,text width=1cm,align=center,minimum height=2.5cm,minimum width=2.5cm] (7) {翻译};
		\node[rectangle,left = of 6,text width=0.5cm] (8) {归约};
		\node[rectangle,right = of 7,text width=0.5cm] (9) {IR \\ 树};
		\node[rectangle,draw=black,right = of 9,text width=1.5cm,align=center,minimum height=2.5cm,minimum width=2.5cm] (10) {规范化};
		\node[rectangle,right = of 10,text width=0.5cm] (11) {IR \\ 树};
		\node[rectangle,draw=black,right = of 11,text width=1cm,align=center,minimum height=2.5cm,minimum width=2.5cm] (12) {指令选择};
		\node[rectangle,right = of 12,text width=0.5cm] (13) {汇编};
		\node[rectangle,draw=black,left = of 8,text width=1cm,align=center,minimum height=2.5cm,minimum width=2.5cm] (14) {语法分析};
		\node[rectangle,left = of 14,text width=0.5cm] (15) {标记符号};
		\node[rectangle,draw=black,left = of 15,text width=1cm,align=center,minimum height=2.5cm,minimum width=2.5cm] (16) {词法分析};
		\node[rectangle,left = of 16,text width=0.5cm] (17) {源程序};
		\node[rectangle,below = of 7,text width=0.5cm] (18) {帧};
		\node[rectangle,draw=black,below = of 18,text width=1cm,align=center,minimum height=2.5cm,minimum width=2.5cm] (19) {栈帧布局};
		\node[rectangle,draw=black,below = of 14,text width=1.5cm,align=center,minimum height=2.5cm,minimum width=2.5cm,yshift=-12cm] (20) {控制流分析};
		\node[rectangle,left = of 20,text width=0.5cm] (21) {汇编};
		\node[rectangle,right = of 20,text width=0.5cm] (22) {流图};
		\node[rectangle,draw=black,right = of 22,text width=1.5cm,align=center,minimum height=2.5cm,minimum width=2.5cm] (23) {数据流分析};
		\node[rectangle,right = of 23,text width=0.5cm] (24) {冲突图};
		\node[rectangle,draw=black,right = of 24,text width=1.5cm,align=center,minimum height=2.5cm,minimum width=2.5cm] (25) {寄存器分配};
		\node[rectangle,right = of 25,text width=0.5cm] (26) {寄存器指派};
		\node[rectangle,draw=black,right = of 26,text width=1.5cm,align=center,minimum height=2.5cm,minimum width=2.5cm] (27) {代码流出};
		\node[rectangle,right = of 27,text width=0.5cm] (28) {汇编语言};
		\node[rectangle,draw=black,right = of 28,text width=1.5cm,align=center,minimum height=2.5cm,minimum width=2.5cm] (29) {汇编器};
		\node[rectangle,right = of 29,text width=0.5cm] (30) {可重定位代码};
		\node[rectangle,draw=black,right = of 30,text width=1.5cm,align=center,minimum height=2.5cm,minimum width=2.5cm] (31) {连接器};
		\node[rectangle,right = of 31,text width=0.5cm] (32) {机器语言};

		\draw [thick,->] (13) to [out=-30,in=120] (21);
	\end{tikzpicture}
	}
  \caption{编译器的各个阶段及其之间的接口}
  \label{fig:1-1}
\end{figure}

将编译器分解成这样的多个阶段是为了能够重用它的各种构件。例如，当要改变此编译器所生成的机器语言的目标机时，只要改变栈帧布局（Frame Layout）模块和指令选择（Instruction Selection）模块就够了。当要改变被编译的源语言时，则至多只需改变翻译（Translate）模块之前的模块就可以了，该编译器也可以在\textit{抽象语法}（Abstract Syntax）接口处与面向对象的语法编辑器相连。

每个学生都不应缺少反复多次“\textit{思考-实现-重新设计}”，从而获得正确的抽象这样一种学习经历。但是，想要学生在一个学期内实现一个编译器是不现实的。因此，我在书中给出了一个项目框架，其中的模块和接口都经过深思熟虑，而且尽可能地使之既精巧又通用。

\textit{抽象语法}（Abstract Syntax）、IR\textit{树}（IR Tree）和\textit{汇编}（Assem）之类的接口是数据结构的形式，例如语法分析动作阶段建立\textit{抽象语法}数据结构，并将它传递给语义分析阶段。另一些接口是抽象数据类型：\textit{翻译}接口是一组可由语义分析阶段调用的函数；\textit{标记符号}（Token）接口是函数形式，分析器通过调用它而得到输入程序中的下一个标记符号。

\textbf{各个阶段的描述}

第一部分的每一章各描述编译器的一个阶段，具体如表\ref{tab:compiler-phases}所示。

\begin{table}[htbp]
  \centering
  \caption{编译器的各阶段}
    \begin{tabular}{p{1cm}|p{2cm}|p{10cm}}
    \toprule
    \textbf{章号} & \textbf{阶段} & \textbf{描述} \\
    \midrule
    2 & 词法分析 & 将源文件分解成一个个独立的\textit{标记符号} \\
    \midrule
    3 & 语法分析 & 分析程序的短语结构 \\
    \midrule
    4 & 语义动作 & 建立每个短语对应的\textit{抽象语法树} \\
    \midrule
    5 & 语义分析 & 确定每个短语的含义，建立变量和其声明的关联，检查表达式的类型，翻译每个短语 \\
    \midrule
    6 & 栈帧布局 & 按机器要求的方式将变量、函数参数等分配于活动记录（即栈帧）内 \\
    \midrule
    7 & 翻译 & 生成\textit{中间表示树}（IR树），这是一种与任何特定程序设计语言和目标机体系结构无关的表示 \\
    \midrule
    8 & 规范化 & 提取表达式中的副作用，整理条件分支，以方便下一阶段的处理 \\
    \midrule
    9 & 指令选择 & 将IR树结点组合成与目标机指令的动作相对应的块 \\
    \midrule
    10 & 控制流分析 & 分析指令的顺序并建立\textit{控制流图}，此图表示程序执行时可能流经的所有控制流 \\
    \midrule
    10 & 数据流分析 & 收集程序变量的数据流信息。例如，\textit{活跃分析}（liveness analysis）计算每一个变量仍需使用其值的地点（即它的\textit{活跃点}） \\
    \midrule
    11 & 寄存器分配 & 为程序中的每一个变量和临时数据选择一个寄存器，不在同一时间活跃的两个变量可以共享同一个寄存器 \\
    \midrule
    12 & 代码流出 & 用机器寄存器替代每一条机器指令中出现的临时变量名 \\
    \bottomrule
    \end{tabular}
  \label{tab:compiler-phases}
\end{table}

这种模块化设计是很多真实编译器的典型设计。但是，也有一些编译器把语法分析、语义分析、翻译和规范化合并成一个阶段，还有一些编译器将指令选择安排在更后一些的位置，并且将它与代码流出合并在一起。简单的编译器通常没有专门的控制流分析、数据流分析和寄存器分配阶段。

我在设计本书的编译器时尽可能地进行了简化，但并不意味着它是一个简单的编译器。具体而言，虽然为简化设计而去掉了一些细枝末节，但该编译器的结构仍然可以允许增加更多的优化或语义而不会违背现存的接口。

\section{工具和软件}

现代编译器中使用的两种最有用的抽象是\textit{上下文无关文法}（context-free grammar）和\textit{正则表达式}（regular expression）。上下文无关文法用于语法分析，正则表达式用于词法分析。为了更好地利用这两种抽象，较好的做法是借助一些专门的工具，例如Yacc（它将文法转换成语法分析器）和Lex（它将一个说明性的规范转换成一个词法分析器）。幸运的是，ML语言提供了这些工具的比较好的版本，所以本书中的项目ML提供的工具来描述。

本书中的编程项目可以使用Standard ML of New Jersey系统来编译，这个系统中还包含了像ML-Yacc、ML-Lex以及Standard ML of New Jersey Software Library。所有这些工具都可以在因特网上免费获取；具体信息可以查看网页：

\href{http://www.cs.princeton.edu/\textasciitilde appel/modern/ml}{http://www.cs.princeton.edu/\textasciitilde appel/modern/ml}。

Tiger编译器中某些模块的源代码、某些程序设计习题的框架源代码和支持代码、Tiger程序的例子以及其他一些有用的文件都可以从该网址中找到。本书的程序设计习题中，当提及特定子目录或文件所在的某个目录时，指的是目录\$TIGER/。

\section{树语言的数据结构}

编译器中使用的许多重要数据结构都是被编译程序的\textit{中间表示}。这些表示常常采用树的形式，树的结点有若干类型，每一种类型都有一些不同的属性。这种树可以作为图1-1所示的许多阶段的接口。

树表示可以用文法来描述，就像程序设计语言一样。为了介绍有关概念，我将给出一种简单的程序设计语言，该语言有语句和表达式，但是没有循环或if语句[这种语言称为\textit{直线式程序}（straight-line program）语言]。

该语言的语法在文法\ref{grammar:1}中给出。

\renewcommand\tablename{文法}
\begin{table}[htbp]
  \centering
  \begin{tabular}{llll}
  $Stm$ & $\rightarrow$ & $Stm$ ; $Stm$ & (CompoundStm) \\
  $Stm$ & $\rightarrow$ & id := $Exp$ & (AssignStm) \\
  $Stm$ & $\rightarrow$ & print ( $ExpList$ ) & (PrintStm) \\
  $Exp$ & $\rightarrow$ & id & (IdExp) \\
  $Exp$ & $\rightarrow$ & num & (NumExp) \\
  $Exp$ & $\rightarrow$ & $Exp \; Binop \; Exp$ & (OpExp) \\
  $Exp$ & $\rightarrow$ & ( $Stm$ , $Exp$ ) & (EseqExp) \\
  $ExpList$ & $\rightarrow$ & $Exp$ , $ExpList$ & (PairExpList) \\
  $ExpList$ & $\rightarrow$ & $Exp$ & (LastExpList) \\
  $Binop$ & $\rightarrow$ & $+$ & (Plus) \\
  $Binop$ & $\rightarrow$ & $-$ & (Minus) \\
  $Binop$ & $\rightarrow$ & $\times$ & (Times) \\
  $Binop$ & $\rightarrow$ & $/$ & (Div) \\
  \end{tabular}
  \caption{直线式程序设计语言}\label{grammar:1}
\end{table}
\renewcommand\tablename{表}

这个语言的非形式语义如下。每一个$Stm$是一个语句，每一个$Exp$是一个表达式。$s_1;s_2$表示先执行语句$s_1$，再执行语句$s_2$。$i := e$表示先计算表达式$e$的值，然后把计算结果赋给变量$i$。print($e_1,e_2,\cdots,e_n$)表示从左到右输出所有表达式的值，这些值之间用空格分开并以换行符结束。

\textit{标识符表达式}，例如$i$，表示变量$i$的当前内容。\textit{数}按命名它的整数计值。\textit{运算符表达式}$e_1$ op $e_2$表示先计算$e_1$再计算$e_2$，然后按给定的二元运算符计算表达式结果。\textit{表达式序列}$(s,e)$的行为类似于C语言中的逗号运算符，在计算表达式$e$（并返回其结果）之前先计算语句$s$的副作用。

例如，执行下面这段程序：

\begin{minted}{sml}
a := 5+3; b := (print(a, a-1), 10*a); print(b);  
\end{minted}

将打印出：

\begin{minted}{text}
8 7
80
\end{minted}

那么，这段程序在编译器内部是如何表示的呢？一种表示是\textit{源代码}形式，即程序员所编写的字符，但这种表示不易处理。较为方便的表示是树数据结构。每一条语句（$Stm$）和每一个表达式（$Exp$）都有一个树结点。图\ref{fig:1-2}给出了这个程序的树表示，其中结点都用文法\ref{grammar:1}中产生式的标识加以标记，并且每个结点的子节点数量与相应文法产生式右边的符号个数相同。

\begin{figure}[htbp]
\centering
\scalebox{.6}{
\begin{tikzpicture}
  \node (1) {CompoundStm} [sibling distance=2.5cm]
    child {node [xshift=-6cm] {AssignStm}
    child {node {a}}
    child {node {OpExp}
    child {node {NumExp}
    child {node {5}}}
    child {node {Plus}}
    child {node {NumExp}
    child {node {5}}}}}
    child {node [xshift=6cm] {CompoundStm}
    child {node [xshift=-3cm] {AssignStm}
    child {node {b}}
    child {node {EseqExp}
    child {node [xshift=-3cm] {PrintStm}
    child {node {PairExpList}
    child {node {IdExp}
    child {node {a}}}
    child {node {LastExpList}
    child {node {OpExp}
    child {node {IdExp}
    child {node {a}}}
    child {node {Minus}}
    child {node {NumExp}
    child {node {1}}}}}}}
    child {node [xshift=3cm] {OpExp}
    child {node {NumExp}
    child {node {10}}}
    child {node {Times}}
    child {node {IdExp}
    child {node {a}}}}}}
    child {node [xshift=6cm] {PrintStm}
    child {node {LastExpList}
    child {node {IdExp}
    child {node {b}}}}}};
  \node[rectangle,below = of 1,xshift=3cm,yshift=-13cm,minimum width=10cm] (2) {
      \huge a := 5 + 3 ; b := ( print ( a , a - 1 ) , 10 * a ) ; print ( b )
  };
\end{tikzpicture}
}
\caption{直线式程序的树形表示}
\label{fig:1-2}
\end{figure}

我们可以将这个文法直接翻译成数据结构定义，如程序\ref{code:1}所示。每个文法符号对应于这些数据结构中的一个type。

每一项文法规则都有一个\textit{构造器}（constructor），隶属于规则左部符号的类型（type）。ML语言的datatype声明语法可以非常漂亮地表达这些树形结构。这些构造器的名字在文法\ref{grammar:1}各项右部的括号内。

\begin{code}
\captionof{listing}{直线式程序的表示}
\label{code:1}
\begin{minted}{sml}
type id = string

datatype binop = Plus | Minus | Times | Div

datatype stm = CompoundStm of stm * stm
             | AssignStm of id * stm
             | PrintStm of exp list

     and exp = IdExp of id
             | NumExp of int
             | OpExp of exp * binop * exp
             | EseqExp of stm * exp
\end{minted}
\end{code}

\textbf{ML程序的模块化规则}。编译器是一个很大的程序，仔细地设计模块和接口能避免混乱。在用ML语言编写一个编译器时，我们将使用如下一些规则。

\begin{enumerate}
  \item 编译器的每个阶段或者模块都应该归入各自的structure。
  \item 我们将不会使用open声明。如果一个ML文件以如下开头：
  \begin{minted}{sml}
    open A.F; open A.G; open B; open C;
  \end{minted}
  那么你（一个人类读者）\textit{将必须查看一下这个文件之外的代码}来确定X.put()表达式中的X是在哪一个structure中定义的。

  structure的缩略形式将会是一个比较好的解决方案。如果一个模块以如下开头：
  \begin{minted}{sml}
    structure W=A.F.W and X=A.G.X and Y=B.Y and Z=C.Z
  \end{minted}
  那么你\textit{无需查看这个文件外的代码}就可以确定X来自A.G。
\end{enumerate}

\section{程序设计：直线式程序解释器}

为直线程序设计语言实现一个简单的程序分析器和解释器。对\textit{环境}（即符号表，它将变量名映射到这些变量相关的信息）、\textit{抽象语法}（表示程序的短语结构的数据结构）、\textit{树数据结构的递归性}（它对于编译器中很多部分都是非常有用的）以及无赋值语句的\textit{函数式风格}程序设计，这可作为入门练习。

这个练习也可以作为ML语言程序设计的热身。熟悉其他语言但对ML语言陌生的程序员应该也能完成这个习题，只是需要有关ML语言的辅助资料（如教材）的帮助。

需要进行解释的程序已经被分析为抽象语法，这种抽象语法如程序1-5中的数据类型所示。

但是，我们并不希望涉及该语言的具体分析细节，因此利用了相应数据的构造器来编写该程序：

\begin{minted}{sml}
val prog =
 CompoundStm(AssignStm("a",OpExp(NumExp 5, Plus, NumExp 3)),
  CompoundStm(AssignStm("b",
      EseqExp(PrintStm[IdExp "a",OpExp(IdExp "a", Minus,
                                       NumExp 1)],
           OpExp(NumExp 10, Times, IdExp "a"))),
   PrintStm[IdExp "b"]))
\end{minted}

在目录\$TIGER/chap1中可以找到包含树的数据类型声明的文件以及这个样板程序。

编写没有副作用（即更新变量和数据结构的赋值语句）的解释器是理解\textit{指称语义}（denotational semantic）和\textit{属性文法}（attribute grammar）的好方法，后两者都是描述程序设计语言做什么的方法。对编写编译器而言，它也常常是很有用的技术，因为编译器也需要知道程序设计语言做的是什么。

因此，在实现这些程序时，不要使用引用变量，数组或者赋值表达式等ML语言的语法特性。

\begin{enumerate}
  \item 写一个函数(maxargs : stm $\rightarrow$ int)，告知给定语句中所有子表达式内的print语句中包含最大参数数量的print语句的参数个数。例如，maxargs(prog)是2。
  \item 写一个函数interp : stm $\rightarrow$ unit，对一个用这种直线式程序语言写的程序进行“解释”。使用“函数式”的风格来编写这个函数——不使用赋值（:=）或者数组特性——维护一个（变量，整型）偶对\footnote{pair}所组成的列表，然后再解释每个AssignStm时，产生这个列表的新版本。
\end{enumerate}

对于第一个程序，要记住print语句可能会包含一些表达式，而这些表达式中又包含了其他的print语句。

对于第二个程序，编写两个互相递归调用的函数interpStm和interpExp。构造一个“表”，将标识符映射到赋值给标识符的整型数值，“表”使用id $\times$ int偶对所组成的列表来实现。那么interpStm的类型是：stm $\times$ table $\rightarrow$ table，如果表$t_1$作为参数的话，那么返回值将会是一个新的表$t_2$，$t_2$和$t_1$基本相同。不同的是，作为语句的执行结果，一些标识符被映射到了一些不同的整型数值。

例如，表$t_1$中$a$映射到了$3$，$c$映射到了$4$，我们将$t_1$写成$\{a \mapsto 3,c \mapsto 4\}$这样的数学符号，还可以将$t_1$写成链表的形式
\begin{tikzpicture}[list/.style={rectangle split, rectangle split parts=3,draw, rectangle split horizontal}, >=stealth, start chain,baseline=-1mm]
\node[list,on chain] (A) {a \nodepart{second} $3$};
\node[list,on chain] (B) {c \nodepart{second} $4$};
\draw (B.two split south) -- (B.north east);
\draw[*->] let \p1 = (A.three), \p2 = (A.center) in (\x1,\y2) -- (B);
\end{tikzpicture}
，写成ML代码是\mintinline{sml}{("a",3)::("c",4)::nil}。

现在，令表$t_2$就像表$t_1$，不同的是，$c$映射到了$7$而不是$4$。我们可以将这个过程写为以下数学形式：

$t_2=update(t_1,c,7)$

其中函数update返回一个新表$\{a \mapsto 3,c \mapsto 7\}$。

在计算机中，只要我们假设在链表中$c$的\textit{第一次}出现优先于它较后的任何出现，就可以通过在表头插入一个新元素来实现新表$t_2$
\begin{tikzpicture}[list/.style={rectangle split, rectangle split parts=3,draw, rectangle split horizontal}, >=stealth, start chain,baseline=-1mm]
\node[list,on chain] (C) {c \nodepart{second} $7$};
\node[list,on chain] (A) {a \nodepart{second} $3$};
\node[list,on chain] (B) {c \nodepart{second} $4$};
\draw (B.two split south) -- (B.north east);
\draw[*->] let \p1 = (A.three), \p2 = (A.center) in (\x1,\y2) -- (B);
\draw[*->] let \p1 = (C.three), \p2 = (C.center) in (\x1,\y2) -- (A);
\end{tikzpicture}
。

因此，update函数很容易实现，而与之相应的lookup函数

\begin{minted}{sml}
val lookup : table * id -> int
\end{minted}

则只要沿着链表从头向后搜索即可。

表达式的解释要比语句的解释复杂一些，因为表达式返回整型数值\textit{且}有副作用。我们希望解释器本身在模拟直线程序设计语言的赋值语句时不产生任何副作用（但是print语句将有解释器的副作用来实现）。实现它的方法是将interpExp的类型设计成exp $\times$ table $\rightarrow$ int $\times$ table。用表$t_1$解释表达式$e_1$的结果是得到一个整型数值$i$和一个新表$t_2$。当解释一个含有两个子表达式的表达式（例如OpExp）时，由第一个子表达式得到的表$t_2$可以继续用于处理第二个子表达式。

\section{习题}
\definecolor{myblue}{RGB}{60, 113, 183}

\begin{enumerate}
  \item 下面这个简单的程序实现了一种\textit{持久化}（persistent）函数式二叉搜索树，使得如果\mintinline{sml}{tree2 = insert(x, tree1)}，则当使用tree2时，tree1仍然可以继续用于查找。
  \begin{minted}{sml}
    type key = string
    datatype tree = LEAF | TREE of tree * key * tree

    val empty = LEAF

    fun insert(key, LEAF) = TREE(LEAF, key, LEAF)
      | insert(key, TREE(l, k, r)) =
                    if key < k
                      then TREE(insert(key, l), k, r)
                    else if key > k
                      then TREE(l, k, insert(key, r))
                    else TREE(l, key, r)
  \end{minted}
  \begin{enumerate}
    \item 实现函数member，若查找到了相应项，返回true，否则返回false。
    \item 扩充这个程序使其不仅包含成员关系，而且还包含了键值（key）到绑定的映射。
    \begin{minted}{sml}
      datatype 'a tree = ...
      insert : 'a tree * key * 'a -> 'a tree
      lookup : 'a tree * key -> 'a
    \end{minted}
    \item 这个程序构造的树是不平衡的；用下述插入顺序说明树的形成过程：
    \begin{enumerate}
      \item t s p i p f b s t
      \item a b c d e f g h i
    \end{enumerate}
    \item [\textcolor{myblue}{(*d).}] 研究Sedgewick[1997]中讨论过的平衡搜索树，并为函数式符号表推荐一种平衡树数据结构。\textbf{提示：}为了保持函数式风格，算法应该在插入时而不是在查找时保持树的平衡，因此，不适合使用类似于\textit{伸展树}（splay tree）这样的数据结构。
  \end{enumerate}
\end{enumerate}

\chapter{词法分析}

\epigraph{\textbf{词法的}（lex-i-cal）：与语言的单词或词汇有关，但有别于语言的文法和结构。}{韦氏词典}

为了将一个程序从一种语言翻译成另一种语言，编译器必须首先把程序的各种成分拆开，并搞清其结构和含义，然后再用另一种方式把这些成分组合起来。编译器的前端执行分析，后端进行合成。

分析一般分为以下三种。

\begin{itemize}
  \item \textbf{词法分析：}将输入分解成一个个独立的词法符号，即“标记符号”（token），简称标记。
  \item \textbf{语法分析：}分析程序的短语结构。
  \item \textbf{语义分析：}推算程序的含义。
\end{itemize}

词法分析器以字符流作为输入，生成一系列的名字、关键字和标点符号，同时抛弃标记之间的空白符和注释。程序中每个地方都有可能出现空白符和注释，如果让语法分析器来处理它们就会使得语法分析过于复杂，这便是将词法分析从语法分析中分离出去的主要原因。

词法分析并不太复杂，但是我们却使用能力强大的形式化方法和工具来实现它，因为类似的形式化方法对语法分析研究很有帮助，并且类似的工具还可以应用于编译器以外的其他领域。

\section{词法标记}

词法标记是字符组成的序列，可以将其看作程序设计语言的文法单位。程序设计语言的词法标记可以归类为有限的几组标记类型。例如，典型程序设计语言的一些标记类型为：

\begin{table}[htbp]
  \centering
  \begin{tabular}{ll}
    \textbf{类型} & \textbf{例子} \\
    \midrule
    ID & foo \; n14 \; last \\
    NUM & 73 \; 0 \; 00 \; 515 \; 082 \\
    REAL & 66.1 \; .5 \; 10. \; 1e67 \; 5.5e-10 \\
    IF & if \\
    COMMA & , \\
    NOTEQ & != \\
    LPAREN & ( \\
    RPAREN & ) \\
  \end{tabular}
\end{table}

IF、VOID、RETURN等由字母字符组成的标记成为\textit{保留字}（reserved word），在多数语言中，它们不能作为标识符使用。

不是标记的例子有：

\begin{table}[htbp]
  \centering
  \begin{tabular}{ll}
    注释 & /* try again */ \\
    预处理命令 & \#include <stdio.h> \\
    预处理命令 & \#define NUMS 5 , 6 \\
    宏 & NUMS \\
    空格符、制表符和换行符 & \\
  \end{tabular}
\end{table}

在能力较弱而需要宏预处理器的语言中，由预处理器处理源程序的字符流，并生成另外的字符流，然后由词法分析器读入这个新产生的字符流。这种宏处理过程也可以与词法分析集成到一起。

对于下面一段程序：

\begin{minted}{c}
  float match0(char *s) /* find a zero */
  {if (!strncmp(s, "0.0", 3))
    return 0.;
  }
\end{minted}

词法分析器将返回下列标记流：

\begin{minted}{text}
  FLOAT    ID(match0)    LPAREN    CHAR    STAR    ID(s)    RPAREN
  LBRACE     IF  LPAREN     BANG    ID(strncmp)    LPAREN    ID(s)
  COMMA      STRING(0.0)    COMMA     NUM(3)     RPAREN     RPAREN
  RETURN     REAL(0.0)    SEMI  RBRACE    EOF
\end{minted}

其中报告了每个标记的标记类型。这些标记中的一些（如标识符和字面量）有\textit{语义值}与之相连，因此，词法分析器还给出了除标记类型之外的附加信息。

应当如何描述程序设计语言的词法规则？词法分析器又应当用什么样的语言来编写呢？

我们可以用自然语言来描述一种语言的词法标记。例如，下面是对C或Java中标识符的一种描述：

\begin{quote}
  \textit{标识符是字母和数字组成的序列，第一个字符必须是字母。下划线“\_”视为字母。大小写字母不同。如果经过若干标记分析后输入流已到达一个给定的字符，则下一个标记将由有可能组成一个标记的最长字符串所组成。其中的空格符、制表符、换行符和注释都将被忽略，除非它们作为独立的一类标记。另外需要有某种空白符来分隔相邻的标识符、关键字和常数。}
\end{quote}

任何合理的程序设计语言都可以用来实现特定的词法分析器。我们将用\textit{正则表达式}的形式语言来指明词法标记，用\textit{确定的有限自动机}来实现词法分析器，并用数学的方法将两者联系起来。这样将得到一个简单且可读性更好的词法分析器。

\section{正则表达式}

我们说\textit{语言}（language）是字符串组成的集合，字符串是\textit{符号}（symbol）的有限序列。符号本身来自有限\textit{字母表}（alphabet）。

Pascal语言是所有组成合法Pascal程序的字符串的集合，素数语言是构成素数的所有十进制数字字符串的集合，C语言保留字是C程序设计语言中不能作为标识符使用的所有字母数字字符串组成的集合。这3种语言中，前两种是无限集合，后一种是有限集合。在这3种语言中，字母表都是ASCII字符集。

以这种方式谈论语言时，我们并没有给其中的字符串赋予任何含义，而只是企图确定每个字符串是否属于其语言。

为了用有限的描述来指明这类（很可能是无限的）语言，我们将使用\textit{正则表达式}（regular expression）表示法。每个正则表达式代表一个字符串集合。

\begin{itemize}
  \item \textbf{符号}（symbol）：对于语言字母表中的每个符号\textbf{a}，正则表达式\textbf{a}表示仅包含字符串a的语言。
  \item \textbf{或}（alternation）：对于给定的两个正则表达式\textbf{M}和\textbf{N}，或运算符（|）形成一个新的正则表达式\textbf{M | N}。如果一个字符串属于语言\textbf{M}或者语言\textbf{N}，则它属于语言\textbf{M | N}。因此，\textbf{a | b}组成的语言包含a和b这两个字符串。
  \item \textbf{联结}（concatenation）：对于给定的两个正则表达式\textbf{M}和\textbf{N}，联结运算符（$\boldsymbol{\cdot}$）形成一个新的正则表达式$\textbf{M}\boldsymbol{\cdot}\textbf{N}$。如果一个字符串是任意两个字符串$\alpha$和$\beta$的联结，且$\alpha$属于语言\textbf{M}，$\beta$属于语言\textbf{N}，则该字符串属于$\textbf{M}\boldsymbol{\cdot}\textbf{N}$组成的语言。因此，正则表达式$(\textbf{a} | \textbf{b})\boldsymbol{\cdot} \textbf{a}$定义了包含两个字符串aa和ba的语言。
  \item $\epsilon$（epsilon）：正则表达式$\epsilon$表示仅含一个空字符串的语言。因此，$(\textbf{a}\boldsymbol{\cdot}\textbf{b})|\epsilon$表示语言\{"", "ab"\}。
  \item \textbf{重复}（repetition）：对于给定的正则表达式\textbf{M}，它的克林闭包（Kleene closure）是$\textbf{M}^*$。如果一个字符串是由$M$中的字符串经零至多次联结运算的结果，则该字符串属于$\textbf{M}^*$。因此，$((\textbf{a}|\textbf{b})\boldsymbol{\cdot}\textbf{a})^*$表示无穷集合\{"", "aa", "ba", "aaaa", "baaa", "aaba", "baba", "aaaaaa", $\cdots$\}。
\end{itemize}

通过使用符号、或、联结、$\epsilon$和克林闭包，我们可以规定与程序设计语言词法单词相对应的ASCII字符集。首先，考虑若干例子：

\begin{table}[htbp]
  \centering
  \begin{tabular}{ll}
    $(\textbf{0}|\textbf{1})^*\boldsymbol{\cdot}\textbf{0}$ & 由2的倍数组成的二进制数。\\
    $\textbf{b}^*(\textbf{abb}^*)^*(\textbf{a}|\epsilon)$ & 由a和b组成，但a不连续出现的字符串。\\
    $(\textbf{a}|\textbf{b})^*\textbf{aa}(\textbf{a}|\textbf{b})^*$ & 由a和b组成，且有连续出现a的字符串。\\
  \end{tabular}
\end{table}

在书写正则表达式时，我们有时会省略联结运算符或$\epsilon$符号，并假定克林闭包的优先级高于联结运算，联结运算的优先级高于或运算，所以$\textbf{ab}|\textbf{c}$表示$(\textbf{a}\boldsymbol{\cdot}\textbf{b})|\textbf{c}$，而$(\textbf{a}|)$表示$(\textbf{a}|\epsilon)$。

还有一些更为简洁的缩写形式：[\textbf{abcd}]表示$(\textbf{a}|\textbf{b}|\textbf{c}|\textbf{d})$，[\textbf{b-g}]表示[\textbf{bcdefg}]，[\textbf{b-gM-Qkr}]表示[\textbf{bcdefgMNOPQkr}]，\textbf{M}?表示$(\textbf{M}|\epsilon)$，$\textbf{M}^+$表示$\textbf{M}\boldsymbol{\cdot}\textbf{M}^*$。这些扩充很方便，但它们并没有扩充正则表达式的描述能力：任何可以用这些简写形式描述的字符串集合都可以用基本运算符集合来描述。图\ref{fig:2-1}概括了所有这些运算符。

\begin{figure}[htbp]
  \centering
  \begin{tabular}{ll}
    \toprule
    \textbf{a} & 一个表示字符本身的原始字符 \\
    $\epsilon$ & 空字符串 \\
               & 空字符串的另一种写法 \\
    \textbf{M} | \textbf{N} & 或运算符，在\textbf{M}和\textbf{N}之间选择 \\
    \textbf{M} $\boldsymbol{\cdot}$ \textbf{N} & 联结，\textbf{M}之后跟随\textbf{N} \\
    \textbf{MN} & 联结的另一种写法 \\
    $\textbf{M}^*$ & 重复（0次或0次以上） \\
    $\textbf{M}^+$ & 重复（1次或1次以上） \\
    \textbf{M}? & 选择，\textbf{M}的0次或1次的出现 \\
    {[}\textbf{a-zA-Z}{]} & 字符集 \\
    . & 句点表示除换行符之外的任意单个字符 \\
    " a. + * " & 引号，引号中的字符串表示文字字符串本身 \\
    \bottomrule
  \end{tabular}
  \caption{正则表达式表示符号}
  \label{fig:2-1}
\end{figure}

使用这种语言，我们便可以指明程序设计语言的词法标记（见图\ref{fig:2-2}）。对于每一个标记，我们提供一段ML代码，报告识别的是哪种标记类型。

\begin{figure}[htbp]
  \centering
  \begin{tabular}{ll}
    if & (IF); \\
    {[}\textbf{a-z}{]}{[}\textbf{a-z0-9}{]}* & (ID); \\
    {[}\textbf{0-9}{]}+ & (NUM); \\
    ({[}\textbf{0-9}{]}+"."{[}\textbf{0-9}{]}*) | ({[}\textbf{0-9}{]}*"."{[}\textbf{0-9}{]}+) & (REAL); \\
    ("--"{[}\textbf{a-z}{]}*"\textbackslash n") | (" " | "\textbackslash n" | "\textbackslash t")+ & (continue()); \\
    . & (error(); continue()); \\
  \end{tabular}
  \caption{某些标记的正则表达式}
  \label{fig:2-2}
\end{figure}

图\ref{fig:2-2}第5行的描述虽然识别注释或空白，但是不提交给语法分析器，而是忽略它们并重新开始词法分析。这个分析器识别的注释以两个短横线开始，且只包含字母字符，并以换行符结束。

最后，词法规范应当是\textit{完整的}，它应当总是能与输入中的某些初始子串相匹配；使用一个可以与任意字符相匹配的规则，我们便总能做到这一点（在这种情况下，将打印出“illegal character”错误信息，然后再继续进行）。

图\ref{fig:2-2}中的规则存在着二义性。例如，对于if8，应当将它看成一个标识符，还是两个标记if和8？字符串if 89是以一个标识符开头还是以一个保留字开头？Lex，ML-Lex以及其他类似的词法分析器使用了两条消除二义性的重要规则。

\begin{itemize}
  \item \textbf{最长匹配}：初始输入子串中，取可与任何正则表达式匹配的那个最长的字符串作为下一个标记。
  \item \textbf{规则优先}：对于一个\textit{特定的}最长初始子串，第一个与之匹配的正则表达式决定了这个子串的标记类型。也就是说，正则表达式规则的书写顺序有意义。
\end{itemize}

因此，依据最长匹配规则，if8是一个标识符；根据规则优先，if是一个保留字。

\section{有限自动机}

用正则表达式可以很方便地指明词法标记，但我们还需要一种用计算机程序来实现的形式化方法。可以使用有限自动机达到此目的。有限自动机有一个有限\textit{状态}集合和一些从一个状态通向另一个状态的\textit{边}，每条边上标记有一个\textit{符号}；其中一个状态是\textit{初态}，某些状态是\textit{终态}。

图\ref{fig:2-3}给出了一些有限自动机的例子。为了方便讨论，我们给每个状态一个编号。每个例子中的初态都是编号为1的状态。标有多个字符的边是多条平行边的缩写形式；因此，在机器ID中，实际上有26条边从状态1通向状态2，每条边用不同的字母标记。

\begin{figure}[htbp]
  \centering
  \begin{tikzpicture}[node distance = 1cm, initial text = $ $]
    \node[state, initial] (1) {1};
    \node[state, right = of 1] (2) {2};
    \node[state, accepting, right = of 2] (3) {3};

    \draw[->] (1) edge[bend left,above] node{\textbf{i}} (2);
    \draw[->] (2) edge[bend left,above] node{\textbf{f}} (3);

    \node[rectangle,below = of 2] {\textbf{IF}}; 
  \end{tikzpicture}
  \begin{tikzpicture}[node distance = 1cm, initial text = $ $]
    \node[state, initial] (1) {1};
    \node[state, accepting, right = of 1] (2) {2};

    \draw[->] (1) edge[bend left,above] node{\textbf{a-z}} (2);
    \draw[->] (2) edge[loop above] node{\textbf{a-z}} (2);
    \draw[->] (2) edge[loop right] node{\textbf{0-9}} (2);

    \node[rectangle,below left = of 2] {\textbf{ID}};
  \end{tikzpicture}
  \begin{tikzpicture}[node distance = 1cm, initial text = $ $]
    \node[state, initial] (1) {1};
    \node[state, accepting, right = of 1] (2) {2};

    \draw[->] (1) edge[bend left,above] node{\textbf{0-9}} (2);
    \draw[->] (2) edge[loop right] node{\textbf{0-9}} (2);

    \node[rectangle,below left = of 2] {\textbf{NUM}};
  \end{tikzpicture}
  \begin{tikzpicture}[node distance = 1cm, initial text = $ $]
    \node[state, initial] (1) {1};
    \node[state, right = of 1] (2) {2};
    \node[state, accepting, right = of 2] (3) {3};
    \node[state, below right = of 1] (4) {4};
    \node[state, accepting, right = of 4] (5) {5};

    \draw[->] (1) edge[bend left, above] node{\textbf{0-9}} (2);
    \draw[->] (2) edge[loop above] node{\textbf{0-9}} (2);
    \draw[->] (3) edge[loop above] node{\textbf{0-9}} (3);
    \draw[->] (2) edge[bend left, above] node{$\boldsymbol{\cdot}$} (3);
    \draw[->] (1) edge[above] node{$\boldsymbol{\cdot}$} (4);
    \draw[->] (4) edge[bend left,below] node{\textbf{0-9}} (5);
    \draw[->] (5) edge[loop right] node{\textbf{0-9}} (5);

    \node[rectangle,below right = of 4] {\textbf{REAL}};
  \end{tikzpicture}
  \begin{tikzpicture}[node distance = 1cm, initial text = $ $]
    \node[state, initial] (1) {1};
    \node[state, right = of 1] (2) {2};
    \node[state, right = of 2] (3) {3};
    \node[state, accepting, right = of 3] (4) {4};
    \node[state, accepting, below right = of 2] (5) {5};

    \draw[->] (1) edge[below] node{-} (2);
    \draw[->] (2) edge[below] node{-} (3);
    \draw[->] (3) edge[below] node{\textbackslash n} (4);
    \draw[->] (3) edge[loop above] node{\textbf{a-z}} (3);
    \draw[->] (1) edge[bend right,below] node{空白符，等等} (5);
    \draw[->] (5) edge[loop right] node{空白符，等等} (5);

    \node[rectangle,below = of 5] {空白};
  \end{tikzpicture}
  \begin{tikzpicture}[node distance = 2cm, initial text = $ $]
    \node[state, initial] (1) {1};
    \node[state, accepting, right = of 1] (2) {2};

    \draw[->] (1) edge[below] node{除了\textbackslash n} (2);

    \node[rectangle,below right = of 1] {\textbf{error}}; 
  \end{tikzpicture}
  \caption{词法标记的有限自动机。圆圈表示状态，双圆圈表示终态。初态是进入边没有来源的状态。标有多个字符的边是多条平行边的缩写}
  \label{fig:2-3}
\end{figure}

在\textit{确定的}有限自动机（DFA）中，不会有从同一状态出发的两条边标记为相同的符号。DFA以如下方式\textit{接收}或\textit{拒绝}一个字符串：从初始状态出发，对于输入字符串中的每个字符，自动机都将沿着一条确定的边到达另一状态，这条边必须是标有输入字符的边。对n个字符的字符串进行了n次状态转换后，如果自动机到达了终态，自动机将接收该字符串。若到达的不是终态，或者找不到与输入字符相匹配的边，那么自动机将拒绝接收这个字符串。由一个自动机识别的\textit{语言}是该自动机接收的字符串集合。

例如，显然，在由自动机ID识别的语言中，任何字符串都必须以字母开头。任何单字母都能通至状态2，因此单字母字符串是可被接收的字符串。从状态2出发，任何字母和数字都将重新回到状态2，因此一个后跟任意个数字母和数字的字母也将被接收。

事实上，图\ref{fig:2-3}所示的自动机接收的语言与图\ref{fig:2-2}给出的正则表达式相同。

图\ref{fig:2-3}中是6个独立的自动机，如何将它们合并为一个可作为词法分析器的自动机呢？我们将在下一章学习合并它们的形式化方法；在这里只给出合并它们后得到的机器，如图\ref{fig:2-4}所示。机器中的每个终态都必须标明它所接收的标记类型。在这个自动机中，状态2是自动机IF的状态2和自动机ID的状态2的合并；由于状态2是自动机ID的终态，因此这个合并的状态也必须是终态。状态3与自动机IF的状态3和自动机ID的状态2相同，因为这两者都是终态，故我们使用消除二义性的\textit{规则优先}原则将状态3的接收标记类型标为IF。之所以使用规则优先原则是因为我们希望这一标记被识别为保留字，而不是标识符。

这个自动机可用一个转换矩阵来表示。转换矩阵是一个二维数组（一个元素为向量的向量），数组的下标是状态编号和输入字符。其中有一个停滞状态（状态0），这个状态对于任何输入字符都返回到自身，我们用它来表示不存在的边。

\begin{minted}{sml}
  val edges = 
\end{minted}

另外还需要有一个“终结”（finality）数组，它的作用是将状态编号映射至动作。例如，终态2映射到动作ID，等等。

\begin{figure}[htbp]
  \centering
  \begin{tikzpicture}[node distance = 1cm, initial text = $ $]
    \node[state,initial] (1) {1};
    \node[state,accepting,above left = of 1,label=above:ID,yshift=2cm] (2) {2};
    \node[state,accepting,right = of 2,label=above:IF] (3) {3};
    \node[state,accepting,right = of 3,label=above:ID,xshift=1cm] (4) {4};
    \node[state,accepting,right = of 4,label=above:error,xshift=2cm] (5) {5};
    \node[state,accepting,right = of 5,label=above:REAL] (6) {6};
    \node[state,accepting,right = of 1,label=below:NUM,xshift=5cm] (7) {7};
    \node[state,accepting,right = of 7,label=below:REAL] (8) {8};
    \node[state,accepting,below = of 7,label=below:error,yshift=-1cm] (9) {9};
    \node[state,right = of 9] (10) {10};
    \node[state,accepting,right = of 10,label=below:空白] (11) {11};
    \node[state,accepting,below left = of 1,label=below:空白,yshift=-2cm,xshift=-1cm] (12) {12};
    \node[state,accepting,below right = of 1,label=below:error,yshift=-2cm,xshift=1cm] (13) {13};

    \draw[->] (1) edge[below] node{\textbf{i}} (2);
    \draw[->] (2) edge[below] node{\textbf{f}} (3);
    \draw[->] (3) edge[above] node{\textbf{0-9, a-z}} (4);
    \draw[->] (4) edge[loop right] node{\begin{tabular}{l}
      \textbf{0-9} \\
      \textbf{a-z}
    \end{tabular}} (4);
    \draw[->] (1) edge[above] node{\textbf{0-9}} (7);
    \draw[->] (7) edge[above] node{$\boldsymbol{\cdot}$} (8);
    \draw[->] (7) edge[loop above] node{\textbf{0-9}} (7);
    \draw[->] (8) edge[loop above] node{\textbf{0-9}} (8);
    \draw[->] (1) edge[above] node{$\boldsymbol{\cdot}$} (5);
    \draw[->] (1) edge[above] node{\begin{tabular}{l}
      \textbf{a-h} \\ \textbf{j-z}
    \end{tabular}} (4);
    \draw[->] (6) edge[loop right] node{\textbf{0-9}} (6);
    \draw[->] (5) edge[above] node{\textbf{0-9}} (6);
    \draw[->] (1) edge[above] node{\begin{tabular}{l}
      空白符， \\ 等等
    \end{tabular}} (12);
    \draw[->] (12) edge[loop right] node{\begin{tabular}{l}
      空白符，\\ 等等
    \end{tabular}} (12);
    \draw[->] (1) edge[below] node{其他} (13);
    \draw[->] (1) edge[above] node{-} (9);
    \draw[->] (9) edge[above] node{-} (10);
    \draw[->] (10) edge[above] node{\textbackslash n} (11);
    \draw[->] (10) edge[loop below] node{\textbf{a-z}} (10);
  \end{tikzpicture}
  \caption{合并后的有限自动机}
  \label{fig:2-4}
\end{figure}

\textbf{识别最长的匹配}

很容易看出如何使用转换矩阵来识别一个字符串是否会被接收，但是词法分析器的任务是要找到最长的匹配，因为输入中最长的初始子串才是合法的标记。在进行转换的过程中，词法分析器要一直追踪迄今见到的最长匹配以及这个最长匹配的位置。

追踪最长匹配意味着需要用变量Last-Final（最近遇到的终态的编号）和Input-Position-at-Last-Final来记住自动机最后一次处于终态时的时机。每次进入一个终态时，词法分析器都要更新这两个变量，当到达\textit{停滞}状态（无出口转换的非终态状态）时，从这两个变量便能得知所匹配的标记和它的结束位置。

图\ref{fig:2-5}说明了词法分析器识别最长匹配的操作过程。注意，当前输入位置可能相距识别器最近到达终态时的位置已很远。

\begin{figure}[htbp]
  \centering
  \begin{tabular}{llll}
    \toprule
    \textbf{最后的终态} & \textbf{当前状态} & \textbf{当前输入} & \textbf{接收动作} \\
    \midrule
    0 & 1 & \begin{tikzpicture}
      \node[rectangle] (1) {if \; {-}{-}not-a-com};
      \node[rectangle,xshift=-1.2cm,yshift=0.02cm] (2) {$^\top$};
      \node[rectangle,xshift=-1.2cm,yshift=-0.1cm] (3) {$_\perp$};
    \end{tikzpicture} & \\
    2 & 2 & \begin{tikzpicture}
      \node[rectangle] (1) {if \; {-}{-}not-a-com};
      \node[rectangle,xshift=-1.08cm,yshift=0.02cm] (2) {$^\top$};
      \node[rectangle,xshift=-1.08cm,yshift=-0.1cm] (3) {$_\perp$};
      \node[rectangle,xshift=-1.2cm,yshift=-0.02cm] (4) {$\vert$};
    \end{tikzpicture} & \\
    3 & 3 & \begin{tikzpicture}
      \node[rectangle] (1) {if \; {-}{-}not-a-com};
      \node[rectangle,xshift=-0.9cm] (2) {$^\top$};
      \node[rectangle,xshift=-0.9cm,yshift=-0.1cm] (3) {$_\perp$};
      \node[rectangle,xshift=-1.2cm,yshift=-0.02cm] (4) {$\vert$};
    \end{tikzpicture} & \\
    3 & 0 & \begin{tikzpicture}
      \node[rectangle] (1) {if \; {-}{-}not-a-com};
      \node[rectangle,xshift=-0.9cm,yshift=0.01cm] (2) {$^\top$};
      \node[rectangle,xshift=-0.65cm,yshift=-0.1cm] (3) {$_\perp$};
      \node[rectangle,xshift=-1.2cm,yshift=-0.02cm] (4) {$\vert$};
    \end{tikzpicture} & 返回IF \\
    \midrule
    0 & 1 & \begin{tikzpicture}
      \node[rectangle] (1) {if \; {-}{-}not-a-com};
      \node[rectangle,xshift=-0.9cm] (2) {$^\top$};
      \node[rectangle,xshift=-0.9cm,yshift=-0.1cm] (3) {$_\perp$};
    \end{tikzpicture} & \\
    12 & 12 & \begin{tikzpicture}
      \node[rectangle] (1) {if \; {-}{-}not-a-com};
      \node[rectangle,xshift=-0.65cm] (2) {$^\top$};
      \node[rectangle,xshift=-0.65cm,yshift=-0.1cm] (3) {$_\perp$};
      \node[rectangle,xshift=-0.9cm,yshift=0] (4) {$\vert$};
    \end{tikzpicture} & \\
    12 & 0 & \begin{tikzpicture}
      \node[rectangle] (1) {if \; {-}{-}not-a-com};
      \node[rectangle,xshift=-0.65cm] (2) {$^\top$};
      \node[rectangle,xshift=-0.52cm,yshift=-0.12cm] (3) {$_\perp$};
      \node[rectangle,xshift=-0.9cm,yshift=0] (4) {$\vert$};
    \end{tikzpicture} & 找到空白；重新开始 \\
    \midrule
    0 & 1 & \begin{tikzpicture}
      \node[rectangle] (1) {if \; {-}{-}not-a-com};
      \node[rectangle,xshift=-0.65cm] (2) {$^\top$};
      \node[rectangle,xshift=-0.65cm,yshift=-0.1cm] (3) {$_\perp$};
    \end{tikzpicture} & \\
    9 & 9 & \begin{tikzpicture}
      \node[rectangle] (1) {if \; {-}{-}not-a-com};
      \node[rectangle,xshift=-0.52cm] (2) {$^\top$};
      \node[rectangle,xshift=-0.52cm,yshift=-0.1cm] (3) {$_\perp$};
      \node[rectangle,xshift=-0.65cm,yshift=0] (4) {$\vert$};
    \end{tikzpicture} & \\
    9 & 10 & \begin{tikzpicture}
      \node[rectangle] (1) {if \; {-}{-}not-a-com};
      \node[rectangle,xshift=-0.52cm] (2) {$^\top$};
      \node[rectangle,xshift=-0.41cm,yshift=-0.1cm] (3) {$_\perp$};
      \node[rectangle,xshift=-0.66cm,yshift=-0.02cm] (4) {$\vert$};
    \end{tikzpicture} & \\
    9 & 10 & \begin{tikzpicture}
      \node[rectangle] (1) {if \; {-}{-}not-a-com};
      \node[rectangle,xshift=-0.52cm] (2) {$^\top$};
      \node[rectangle,xshift=-0.19cm,yshift=-0.1cm] (3) {$_\perp$};
      \node[rectangle,xshift=-0.66cm,yshift=-0.02cm] (4) {$\vert$};
    \end{tikzpicture} & \\
    9 & 10 & \begin{tikzpicture}
      \node[rectangle] (1) {if \; {-}{-}not-a-com};
      \node[rectangle,xshift=-0.52cm] (2) {$^\top$};
      \node[rectangle,xshift=0cm,yshift=-0.1cm] (3) {$_\perp$};
      \node[rectangle,xshift=-0.66cm,yshift=-0.02cm] (4) {$\vert$};
    \end{tikzpicture} & \\
    9 & 10 & \begin{tikzpicture}
      \node[rectangle] (1) {if \; {-}{-}not-a-com};
      \node[rectangle,xshift=-0.52cm] (2) {$^\top$};
      \node[rectangle,xshift=0.1cm,yshift=-0.1cm] (3) {$_\perp$};
      \node[rectangle,xshift=-0.66cm,yshift=-0.02cm] (4) {$\vert$};
    \end{tikzpicture} & \\
    9 & 0 & \begin{tikzpicture}
      \node[rectangle] (1) {if \; {-}{-}not-a-com};
      \node[rectangle,xshift=-0.52cm] (2) {$^\top$};
      \node[rectangle,xshift=0.21cm,yshift=-0.11cm] (3) {$_\perp$};
      \node[rectangle,xshift=-0.66cm,yshift=-0.02cm] (4) {$\vert$};
    \end{tikzpicture} & 错误；非法标记“-”；重新开始\\
    \midrule
    0 & 1 & \begin{tikzpicture}
      \node[rectangle] (1) {if \; {-}{-}not-a-com};
      \node[rectangle,xshift=-0.52cm] (2) {$^\top$};
      \node[rectangle,xshift=-0.52cm,yshift=-0.1cm] (3) {$_\perp$};
    \end{tikzpicture} & \\
    9 & 9 & \begin{tikzpicture}
      \node[rectangle] (1) {if \; {-}{-}not-a-com};
      \node[rectangle,xshift=-0.40cm] (2) {$^\top$};
      \node[rectangle,xshift=-0.40cm,yshift=-0.1cm] (3) {$_\perp$};
      \node[rectangle,xshift=-0.52cm,yshift=-0.04cm] (4) {$\vert$};
    \end{tikzpicture} & \\
    9 & 0 & \begin{tikzpicture}
      \node[rectangle] (1) {if \; {-}{-}not-a-com};
      \node[rectangle,xshift=-0.40cm] (2) {$^\top$};
      \node[rectangle,xshift=-0.20cm,yshift=-0.1cm] (3) {$_\perp$};
      \node[rectangle,xshift=-0.52cm,yshift=-0.04cm] (4) {$\vert$};
    \end{tikzpicture} & 错误；非法标记“-”；重新开始 \\
    \bottomrule
  \end{tabular}
  \caption{图\ref{fig:2-4}中自动机识别的几个单词。符号“|”指出每次调用词法分析器时的输入位置，符号“”指出自动机的当前位置，符号“”指出自动机最近一次处于终态时的位置}
  \label{fig:2-5}
\end{figure}

\section{非确定性有限自动机}

非确定性有限自动机（NFA）是一种需要对从一个状态出发的多条标有相同符号的边进行选择的自动机。它也可能存有标有$\epsilon$（希腊字母）的边，这种边可以在不接收输入字符的情况下进行状态转换。

下面是一个NFA的例子：

\begin{figure}[htbp]
  \centering
  \begin{tikzpicture}[node distance = 1cm, initial text = $ $]
    \node[state,accepting,initial,initial where = above] (1) {};
    \node[state,right = of 1] (2) {};
    \node[state,accepting,right = of 2] (3) {};
    \node[state,left = of 1] (4) {};
    \node[state,left = of 4] (5) {};
    \node[state,accepting,left = of 5] (6) {};

    \draw[->] (1) edge[bend left,above] node{\textbf{a}} (2);
    \draw[->] (2) edge[bend left,above] node{\textbf{a}} (3);
    \draw[->] (3) edge[bend left,below] node{\textbf{a}} (2);
    \draw[->] (1) edge[bend right,above] node{\textbf{a}} (4);
    \draw[->] (4) edge[bend right,above] node{\textbf{a}} (5);
    \draw[->] (5) edge[bend right,above] node{\textbf{a}} (6);
    \draw[->] (6) edge[bend right,below] node{\textbf{a}} (4);
  \end{tikzpicture}
\end{figure}

在初态时，根据输入字母a，自动机既可向左转换，也可向右转换。若选择了向左转换，则接收的是长度为3的倍数的字符串；若选择了向右转换，则接收的是长度为偶数的字符串。因此，这个NFA识别的语言是长度为2的倍数或3的倍数的所有由字母a组成的字符串的集合。

在第一次转换时，这个自动机必须选择走哪条路。如果存在着\textit{任何}导致该字符串被接收的可选择路径，那么自动机就必须接收该字符串。因此，自动机必须进行“猜测”，并且必须总是作出正确的猜测。

标有$\epsilon$的边可以不使用输入中的字符。下面是接收同样语言的另一个NFA：

\begin{figure}[htbp]
  \centering
  \begin{tikzpicture}[node distance = 1cm, initial text = $ $]
    \node[state,initial,initial where = above] (1) {};
    \node[state,accepting,right = of 1] (2) {};
    \node[state,right = of 2] (3) {};
    \node[state,accepting,left = of 1] (4) {};
    \node[state,left = of 4] (5) {};
    \node[state,left = of 5] (6) {};

    \draw[->] (1) edge[bend left,above] node{$\epsilon$} (2);
    \draw[->] (2) edge[bend left,above] node{\textbf{a}} (3);
    \draw[->] (3) edge[bend left,below] node{\textbf{a}} (2);
    \draw[->] (1) edge[bend right,above] node{$\epsilon$} (4);
    \draw[->] (4) edge[bend right,above] node{\textbf{a}} (5);
    \draw[->] (5) edge[bend right,above] node{\textbf{a}} (6);
    \draw[->] (6) edge[bend right,below] node{\textbf{a}} (4);
  \end{tikzpicture}
\end{figure}

同样地，这个自动机必须决定选取哪一条$\epsilon$边。若存在一个状态既有一些$\epsilon$边，又有一些标有符号的边，则自动机可以选择接收一个输入符号（并沿着标有对应符号的边前进），或者选择沿着$\epsilon$边前进。

\subsection{将正则表达式转换为NFA}

非确定性的自动机是一个很有用的概念，因为它很容易将一个（静态的、说明性的）正则表达式转换成一个（可模拟的、准可执行的）NFA。

转换算法可以将任何一个正则表达式转换为有一个尾巴和一个脑袋的NFA。它的尾巴即开始边，简称为\textit{尾}；脑袋即末端状态，简称为\textit{头}。例如，单个符号的正则表达式\textbf{a}转换成的NFA为：

\begin{figure}[htbp]
  \centering
  \begin{tikzpicture}[node distance = 1cm, initial text = $ $]
    \node[state,draw=none] (1) {};
    \node[state,right = of 1] (2) {};

    \draw[->] (1) edge[bend left,above] node{\textbf{a}} (2);
  \end{tikzpicture}
\end{figure}

由\textbf{a}和\textbf{b}经联结运算而形成的正则表达式\textbf{ab}对应的NFA是由两个NFA组合而成的，即将\textbf{a}的头与\textbf{b}的尾连接起来。由此得到的自动机有一个用\textbf{a}标记的尾和一个从\textbf{b}边进入的头。

\begin{figure}[htbp]
  \centering
  \begin{tikzpicture}[node distance = 1cm, initial text = $ $]
    \node[state,draw=none] (1) {};
    \node[state,right = of 1] (2) {};
    \node[state,right = of 2] (3) {};

    \draw[->] (1) edge[bend left,above] node{\textbf{a}} (2);
    \draw[->] (2) edge[bend left,above] node{\textbf{b}} (3);
  \end{tikzpicture}
\end{figure}

一般而言，任何一个正则表达式\textbf{M}都有一个具有尾和头的NFA：

\begin{figure}[htbp]
  \centering
  \begin{tikzpicture}[node distance = 1cm, initial text = $ $]
    \node[rectangle] (1) {\textbf{M}};
    \node[state,right = of 1] (2) {};

    \draw plot[smooth, tension=.7] coordinates {(-3,0) (-2,0.22) (-1,0.2) (-0.8,0.25) (0.5,0.5) (1.7,0.7) (2.0,0.5) (2.5,0.6) (2.4,-0.5) (2,-0.8) (0,-0.4)(-2,0.22)};
  \end{tikzpicture}
\end{figure}

我们可以归纳地定义正则表达式到NFA的转换。一个正则表达式或者是原语（单个符号或$\epsilon$），或者是由多个较小的表达式组合而成。

图\ref{fig:2-6}展示了将正则表达式转换至NFA的规则。我们用图\ref{fig:2-2}中关于单词IF、ID、NUM以及error的一些表达式来举例说明这种转换算法。每个表达式都转换成了一个NFA，每个NFA的头是用不同标记类型标记的终态结点，并且每一个表达式的尾汇合成一个新的初始结点。由此得到的结果（在合并了某些等价的NFA状态之后）如图\ref{fig:2-7}所示。

\begin{figure}[htbp]
  \centering
  \begin{tabular}{ll}
    \begin{tikzpicture}[node distance = 1cm, initial text = $ $]
      \node[state,draw=none] (1) {};
      \node[state,right = of 1] (2) {};
      \node[rectangle,left = of 1] (3) {\textbf{a}};
  
      \draw[->] (1) edge[bend left,above] node{\textbf{a}} (2);
    \end{tikzpicture} &
    \begin{tikzpicture}
      \node[rectangle] (1) {$\textbf{M}^+$};
      \node[rectangle,right = of 1] (2) {构造为$\textbf{M}\boldsymbol{\cdot}\textbf{M}^*$};
    \end{tikzpicture} \\
    \begin{tikzpicture}[node distance = 1cm, initial text = $ $]
      \node[state,draw=none] (1) {};
      \node[state,right = of 1] (2) {};
      \node[rectangle,left = of 1] (3) {$\epsilon$};
  
      \draw[->] (1) edge[bend left,above] node{$\epsilon$} (2);
    \end{tikzpicture} & \\
  \end{tabular}
  \caption{正则表达式至NFA的转换}
  \label{fig:2-6}
\end{figure}

\begin{figure}[htbp]
  \centering
  \begin{tikzpicture}
    
  \end{tikzpicture}
  \caption{由4个正则表达式转换成的一个NFA}
  \label{fig:2-7}
\end{figure}

\subsection{将NFA转换为DFA}

如在2.3节看到的，用计算机程序实现确定的有限自动机（DFA）较容易。但实现NFA则要困难一些，因为大多数计算机都没有足够好的可以进行“猜测”的硬件。

通过一次同时尝试所有可能的路径，可以避免这种猜测。我们用字符串in来模拟图\ref{fig:2-7}的NFA。首先从状态1开始。现在，替代猜测应采用哪个$\epsilon$转换，我们只是说此时NFA可能选择它们中的任何一个，因此，它是状态\{1,4,9,14\}当中的任何一个，即我们需要计算\{1\}的$\epsilon$\textit{闭包}。显然，不接收输入中的第一个字符，就不可能到达其他状态。

现在要根据字符i来进行转换。从状态1可以到达状态2，从状态4可以到达状态5，从状态9则无处可去，而从状态14则可以到达状态15，由此得到状态集合\{2,5,15\}。但是，我们还必须计算$\epsilon$闭包：从状态5有一个$\epsilon$转换至状态8，从状态8有一个$\epsilon$转换至状态6。因此这个NFA一定属于状态集合\{2,5,6,8,15\}。

对于下一个输入字符n，我们从状态6可到达状态7，但状态2、5、8和15都无相应的转换。因此得到状态集合\{7\}，它的$\epsilon$闭包是\{6,7,8\}。

现在我们已经到达了字符串in的末尾，那么，这个NFA是否已经到达了终态呢？在我们得到的可能状态集合中，状态8是终态，因此in是一个ID标记。

我们形式化地定义$\epsilon$闭包如下。令$\textbf{edge}(s,c)$是从状态$s$沿着标有$c$的一条边可以到达的所有NFA状态的集合。对于状态集合$S$，$\textbf{closure}(S)$是从$S$中的状态出发，无需接收任何字符，即只通过$\epsilon$边便可以到达的状态组成的集合。这种经过$\epsilon$边的概念可用数学方式表述，即$\textbf{closure}(S)$是满足如下条件的最小集合$T$：

$$
T = S \cup (\bigcup_{s \in T} \textbf{edge}(s,\epsilon))
$$

我们可以用迭代法来算出$T$：

\begin{align*}
& T \leftarrow S \\
& \textbf{repeat} \; T' \leftarrow T \\
&    \quad\quad\quad T  \leftarrow T' \cup (\bigcup_{s \in T'} \textbf{edge}(s,\epsilon)) \\
& \textbf{until} \; T = T'
\end{align*}

这个算法为什么是正确的？因为$T$只可能在迭代中扩大，所以最终的$T$一定包含$S$。如果在一次迭代之后有$T=T'$，则$T$也一定包含$\bigcup_{s \in T'} \textbf{edge}(s,\epsilon)$。因为在NFA中只有有限个不同的状态，所以算法一定会终止。

现在，当用前面描述的方法来模拟一个NFA时，假设我们位于由NFA状态$s_i$、$s_k$、$s_l$组成的集合$d=\{s_i,s_k,s_l\}$中。从$d$中的状态出发，并吃进输入符号$c$，将到达NFA的一个新的状态集合；我们称这个集合为$\textbf{DFAedge}(d,c)$：

$$
\textbf{DFAedge}(d,c)=\textbf{closure}(\bigcup_{s \in d} \textbf{edge}(s,c))
$$

利用\textbf{DFAedge}能够更加形式化地写出NFA模拟算法。如果NFA的初态是$s_1$，输入字符串中的字符是$c_1,\cdots,c_k$，则算法为：

\begin{align*}
& d \leftarrow \textbf{closure}(\{s_1\}) \\
& \textbf{for} \; \textit{i} \leftarrow 1 \;\textbf{to}\; \textit{k} \\
& \quad d \leftarrow \textbf{DFAedge}(d,c_i)
\end{align*}

状态集合运算是代价很高的运算——对进行词法分析的源程序中的每一个字符都做这种运算几乎是不现实的。但是，预先计算出所有的状态集合却是有可能的。我们可以由NFA构造一个DFA，使得NFA的每一个状态集合都对应于DFA的一个状态。因为NFA的状态个数有限（$n$个），所以这个DFA的状态个数也是有限的（至多为$2^n$个）。

一旦有了\textbf{closure}和\textbf{DFAedge}的算法，就很容易构造出DFA。DFA的状态$d_1$就是$\textbf{closure}(s_1)$，这同NFA模拟算法一样。抽象而言，如果$d_j=\textbf{DFAedge}(d_i,c)$，则存在着一条从$d_i$到$d_j$的标记为$c$的边。令$\Sigma$是字母表。

\begin{align*}
& states[0] \leftarrow \{\}; \quad\quad states[1] \leftarrow \textbf{closure}(\{s_1\}) \\
& p \leftarrow 1; \quad\quad j \leftarrow 0 \\
& \textbf{while} \; j \leq p \\
& \quad \textbf{foreach} \; c \in \Sigma \\
& \quad\quad e \leftarrow \textbf{DFAedge}(states[j],c) \\
& \quad\quad \textbf{if} \; e = states[i] \; for \; some \; i \leq p \\
& \quad\quad\quad \textbf{then} \; trans[j,c] \leftarrow i \\
& \quad\quad\quad \textbf{else} \;\; p \leftarrow p + 1 \\
& \quad\quad\quad\quad\quad states[p] \leftarrow e \\
& \quad\quad\quad\quad\quad trans[j,c] \leftarrow p \\
& \quad j \leftarrow j + 1
\end{align*}

这个算法不访问DFA的不可到达状态。这一点特别重要，因为原则上DFA有$2^n$个状态，但实际上一般只能找到约$n$个状态是从初始状态可以到达的。这一点对避免DFA解释器的转换表出现指数级的膨胀很重要，因为这个转换表是编译器的一部分。

只要$states[d]$中有任何状态是其NFA中的接受状态，状态$d$就是DFA的\textit{接受状态}。仅仅标志一个状态为\textit{接受状态}是不够的，我们还必须告知它识别的是什么标记，并且$states[d]$中还可能有多个状态是这个NFA的接受状态。在这种情况下，我们用一个适当的标记类型来标识$d$，这个适当的标记类型即组成词法规则的正则表达式中最先出现的那个标记类型。这就是\textit{规则优先}的实现方法。

构造了DFA之后便可以删除“状态”数组，只保留“转换”数组用于词法分析。

对图\ref{fig:2-7}的NFA应用这个DFA构造算法得到了图2-8的自动机。

这个自动机还不是最理想的，也就是说，它不是识别相同语言的最小自动机。一般而言，我们称两个状态$s_1$和$s_2$是等价的，如果开始于$s_1$的机器接收字符串$\sigma$，则它从状态$s_2$开始也一定接收$\sigma$，反之亦然。图2-8中，标为[5,6,8,15]的状态和标为[6,7,8]的状态等价。标为[10,11,13,15]的状态与标为[11,12,13]的状态等价。若自动机存在两个等价状态$s_1$和$s_2$，则我们可以使得所有进入$s_2$的边都指向$s_1$而删除$s_2$。

\begin{figure}[htbp]
  \centering
  \begin{tikzpicture}
    
  \end{tikzpicture}
  \caption{NFA被转化为DFA}
  \label{fig:2-8}
\end{figure}

那么如何才能找出所有等价的状态呢？若$s_1$和$s_2$同为接受状态或同为非接受状态，且对于任意符号$c$，$trans[s_1,c]=trans[s_2,c]$，则显然它们两者等价。容易看出[10,11,13,15]和[11,12,13]满足这个判别条件。但是这个条件的普遍性还不够充分，考虑下面的自动机：

其中状态2和4等价，但是$trans[2,a] \neq trans[4,a]$。

在构造出一个DFA后，用一个算法来找出它的等价状态，并将之最小化是很有好处的；见习题2.6。

\section{ML-Lex：词法分析器的生成器}

构造DFA是一种机械性的工作，很容易由计算机来实现，因此一种有意义的做法是，用\textit{词法分析器的自动生成器}来将正则表达式转换为DFA。

ML-Lex就是这样的一个词法分析器的生成器，它由\textit{词法规范}生成一个ML程序。对于要进行分析的程序设计语言中的每一种标记类型，该规范包含一个正则表达式和一个\textit{动作}。这个动作将标记类型（可能和其他信息一起）传给编译器的下一个处理阶段。

ML-Lex的输出是一个ML程序，即一个词法分析器。该分析器使用2.3节介绍的算法来解释DFA，并根据每一种匹配执行一段动作代码，这段动作代码是用于返回标记类型的ML语句。

图\ref{fig:2-2}描述的标记类型在ML-Lex中的规范如程序\ref{code:2}所示。

\begin{code}
\captionof{listing}{图\ref{fig:2-2}描述的标记的ML-Lex规范}
\label{code:2}
\begin{minted}{sml}
(* ML Declarations: *)
  type lexresult = Tokens.token
  fun eof() = Tokens.EOF(0,0)
  %%
(* Lex Definitions: *)
  digits = [0-9]+
  %%
(* Regular Expressions and Actions *)
  if                    => (Tokens.IF(yypos,yypos+2));
  [a-z][a-z0-9]*        => (Tokens.ID(yytext,yypos,yypos+size yytext));
  {digits}              => (Tokens.NUM(Int.fromString yytext,
                                       yypos,yypos+size yytext));
  ({digits}"."[0-9]*)|([0-9]*"."{digits})
                        => (Tokens.REAL(Real.fromString yytext,
                                        yypos,yypos+size yytext));
  ("--"[a-z]*"\n")|(" ""\n""\t")+
                        => (continue());
                        => (ErrorMsg.error yypos "illegal character";
                            continue());
\end{minted}
\end{code}

该规范的第一部分，即位于第一个“\%\%”标志上面的部分，包含了ML编写的函数和类型。在这一部分里面，必须包含lexresult类型，这个类型是每次调用词法分析函数所产生的结果的类型；而eof函数，将会在词法分析引擎碰到文件结尾时被调用。这一部分也可以包含一些功能函数，作为第三部分的语义动作使用。

这个规范的第二部分包含正则表达式的简写形式和状态说明。例如，在这一部分中的说明digits[0-9]+允许用名字\{digits\}代表正则表达式中非空的数字序列。

第三部分包含正则表达式和动作。这些动作是一段原始的ML代码。每一个动作必须返回一个lexresult类型的值。在这个约定里面，lexresult是Tokens结构中的一个标记。

动作代码中可以使用几个特殊的变量。由正则表达式匹配的字符串是yytext。匹配到的字符串的开始位置在文件中的位置是yypos。函数continue()递归地调用词法分析器。

在这个特定的例子中，每种标记都是一个数据构造器，构造器接受两个整型参数来表示位置——输入文件中的位置——标记开始的位置和结束的位置。

\begin{minted}[escapeinside=\#\#,mathescape=true]{sml}
  structure Tokens =
  struct
     type pos = int
     datatype token = EOF of pos * pos
                    | IF of pos * pos
                    | ID of string * pos * pos
                    | NUM of int * pos * pos
                    | REAL of real * pos * pos
                    #$\vdots$#
  end
\end{minted}

所以，我们将yypos和yypos + size(yytext)这两个值作为参数传递给构造器就可以了。有一些标记关联有\textit{语义值}。例如，ID的语义值是组成标识符的字符串，NUM的语义值是一个整数，而IF则没有语义值（因为每一个IF都有别于其他标记）。所以，ID构造器和NUM构造器都有一个额外的参数来作为语义值，而这个语义值可以从yytext变量计算出来。

\textbf{初始状态}

正则表达式是\textit{静态的}和\textit{说明性的}，自动机是\textit{动态的}和\textit{命令式的}；也就是说，你不必用一个算法来模拟就能看到正则表达式的成分和结构，但是理解自动机常常需要你在自己的头脑中来“执行”它。因此，正则表达式一般更适合于用来知名程序设计语言标记的词法结构。

有时候一步一步地模拟自动机的状态转换过程也是一种合适的做法。ML-Lex有一种将状态和正则表达式混合到一起的机制。你可以声明一组\textit{初始状态}，每个正则表达式的前面可以有一组对它而言是合法的初始状态作为其前缀。动作代码可以明显地改变初态。这相当于我们有这样的一种有限自动机，其边标记的不是符号而是正则表达式。下面的例子给出了一种只由简单标识符、单词if和以“(* ”和“ *)”作为界定符的注释所组成的语言。

尽管有可能写出与整个注释相匹配的单个正则表达式，但是随着注释变得越来越复杂，特别是在允许注释嵌套的情况下，这种正则表达式也会越来越复杂，甚至变得不可能。

与这个机器对应的ML-Lex的规范为：

其中INITIAL是“任何注释之外”的状态。最后一个规则是一种调整，其用途是使得ML-Lex进入此状态。任何不以<STATE>为前缀的正则表达式在所有状态中都能工作，这种特征很少有用处。

利用一个全局变量，并在语义动作中适当增减此全局变量的值，这个例子便很容易扩充成可以处理嵌套的注释。

\section{程序设计：词法分析}

用ML-Lex写出一个Tiger语言的词法分析器。附录中描述了Tiger的词法标记。

本章未对词法分析器应当如何初始化以及它应当如何与编译器的其他部分通信作出说明。你可以从ML-Lex使用手册中得到这些内容，而在\$TIGER/chap2目录中有一个最基本的“脚手架”文件可以帮助你入门。

你应当在连同tiger.lex文件一起提交的文档中描述清楚以下问题：

\begin{itemize}
  \item 你是怎样处理注释的。
  \item 你是怎样处理字符串的。
  \item 错误处理。
  \item 文本结束处理。
  \item 你的词法分析器的其他令人感兴趣的特征。
\end{itemize}

在\$TIGER/chap2中有如下一些可用的支持文件。

\begin{itemize}
  \item tokens.sig，Tokens结构的签名。
  \item tokens.sml，Tokens结构，包含token类型和构造器，你的词法分析器可以用它们来创建token类型的实例。以这种方式来完成词法分析非常重要，因为当把“真正的”语法分析器链接到这个词法分析器的后面，以及使用“真正的”Tokens结构时，所有的代码仍然可以运行。
  \item errormsg.sml，ErrorMsg结构可以用来产生带有文件名和行号的错误信息。
  \item driver.sml，一个运行你的词法分析器来分析输入文件的测试平台。
  \item tiger.lex，tiger.lex文件的初始代码。
  \item sources.cm，ML编译管理器的“makefile”。
\end{itemize}

在阅读附录（Tiger语言参考手册）时，要特别注意以\textbf{标识符}（Identifier）、\textbf{注释}（Comment）、\textbf{整型字面量}（Integer literal）和\textbf{字符串字面量}（String literal）作为标题的段落。

Tiger语言的保留字是：while、for、to、break、let、in、end、function、var、type、array、if、then、else、do、of、nil。

Tiger语言使用的符号是：

, : ; ( ) [ ] \{ \} . + - * / = <> < <= > >= \& | :=

对于字符串字面量，你的词法分析器返回的字符串值应当包含所有已转换到其含义的转义字符。

没有负整型字面量。对于带负号的整型字面量，例如-32，要返回两个标记。

检测没有闭合的注释（在文件末尾）和没有闭合的字符串。

目录\$TIGER/testcases中含有几个简单的Tiger样例程序。

开始时：首先创建一个目录，并复制\$TIGER/chap2中的内容到此目录。用Tiger语言编写一个小程序保存于文件test.tig中。然后，键入sml并输入命令CM.make()；CM（Compilation Manager，编译管理器）将会\textit{使得}系统运行ml-lex命令，如果需要的话，还会编译和链接需要的ML源文件。

最后，Parse.parse "test.tig";命令将会利用一个测试台对该文件进行词法分析。

\section{推荐阅读}

Lex是第一个基于正则表达式的词法分析器的生成器[Lesk 1975]，它现在仍被广泛使用。

将那种还未对它的边进行过$\epsilon$转换检查的状态保存在一个队列或栈中，可以更高效地计算闭包[Aho et al. 1986]。正则表达式可以直接转换成DFA而不需经过NFA[McNaughton and Yamada1960;Aho et al. 1986]。

DFA转换表可能非常大，而且很稀疏。若用一个二维矩阵（状态$\times$符号）来表示这张表则会需要太多的存储空间。在实际中，这个表是经过压缩的。这样做减少了存储空间需求，但却增加了寻找下一状态需要的时间[Aho et al. 1986]。

词法分析器，无论是自动生成的还是手工书写的，都必须有效地处理其输入。当然，输人可以放在缓冲区中，从而一次可以获取成批的字符，然后词法分析器可以每次处理缓冲区中的一个字符。每次读取字符时，词法分析器都必须检查是否已到达缓冲区的末尾。通过在缓冲区末尾放置一个敏感标记（sentinel），即一个不属于任何标记的字符，词法分析器就有可能只对每个标记进行一次检查，而不是对每个字符都进行检查[Aho et al. 1986]。Gray[1988]使用的一种设计可以只需每行检查一次，而不是每个标记检查一次，但它不能适合那种包含行结束字符的标记。Bumbulis和Cowan[1993]的方法只需对DFA中的每一次循环检查一次；当DFA中存在很长的路径时，这可减少检查的次数（相对每个字符一次）。

自动生成的词法分析器常常受到速度太慢的批评。从原理上而言，有限自动机的操作非常简单，因而应该是高效的，但是通过转换表进行解释增加了开销。Gray[1988]指出直接将DFA转换为可执行代码（将状态作为case语句来实现），其速度可以和手工编写的词法分析器一样快。例如，Flex(fast lexical analyzer generator)[Paxson 1995]的速度就比Lex要快许多。

\section{习题}

\chapter{语法分析}

\epigraph{\textbf{语法}（syn-tax）：组合单词以形成词组、从句或句子的方法。}{韦氏词典}

ML-Lex中用一个符号替代某个正则表达式的缩写机制非常方便，这使我们想到用下面的方法来表示一个正则表达式：

\begin{align*}
digits &= [0-9]+ \\
sum &= (digits\text{``}+\text{''})^*digits
\end{align*}

这两个正则表达式定义了形如 28 + 301 + 9 的求和表达式。

但是，考虑下面的定义：

\begin{align*}
digits &= [0-9]+ \\
sum &= expr\text{``}+\text{''}expr \\
expr &= \text{``(''}sum\text{``)''}|digits
\end{align*}

它们定义的是如下形式的表达式：

(109 + 23)

61

(1 + (250 + 3))

其中的所有括号都是配对的。可是有限自动机却不能识别出这种括号配对的情况（因为一个状态数为$N$的自动机无法记忆嵌套深度大于$N$的括号），因此，$sum$和$expr$显然不能是正则表达式。

那么，词法分析器ML-Lex怎样实现类似于$digits$这种缩写形式的正则表达式呢？答案是在将正则表达式翻译成有限自动机之前，简单地用$digits$右部的式子（[0-9]+）替代正则表达式中出现的所有$digits$。

但这种方法对于前面给出的那种$sum$-$expr$语言却行不通；我们虽然可以首先将$expr$中的$sum$替换掉，得到：

$$
expr=\text{``}(\text{''}expr\text{``}+\text{''}expr\text{``})\text{''} \; | \; digits
$$

但是若再用$expr$右部的表达式替换$expr$自身，则得到

$$
expr=\text{``}(\text{''}(\text{``}(\text{''}expr\text{``}+\text{''}expr\text{``})\text{''}|digits)\text{``}+\text{''}expr\text{``})\text{''} \; | \; digits
$$

右部现在仍然同以前一样出现有$expr$，且事实上，$expr$的出现次数不但没有减少反而还增加了！

因此，仅仅这种形式的缩写表示并不能增强正则表达式的语言描述能力（它并没有定义额外的语言），除非这种缩写形式是递归的（或者是相互递归的，如$sum$和$expr$的情形）。

由这种递归而获得的额外的表示能力正好是语法分析需要的。另外，一旦有了递归的缩写形式，则除了在表达式的顶层之外，可以不再需要可选操作。因为定义

$$
expr=ab(c|d)e
$$

可通过一个辅助定义重写为:

\begin{align*}
aux &= c \; | \; d \\
expr &=a \; b \; aux \; e  
\end{align*}

事实上，可以完全不使用可选符号而写出同一个符号的多个可接受的扩展：

\begin{align*}
aux &= c \\
aux &= d \\
expr &= a \; b \; aux \; e
\end{align*}

克林闭包也不再是必需的，我们可以将

$$
expr=(a \; b \; c)*
$$

重写为

\begin{align*}
expr &= (a \; b \; c)expr \\
expr &= \epsilon
\end{align*}

至此我们得到了一种非常简单的表示法，称为上下文无关文法(context-free grammar)。正如正则表达式以一种静态的、说明的方式来定义词法结构一样，文法以说明的方式来定义语法结构。但是我们需要比有限自动机更强大的方法来分析文法所描述的语言。

事实上，文法也可用来描述词法单词的结构；但对于此目的，使用正则表达式要更为适合，也更为简练。

\section{上下文无关文法}

与前面类似，我们认为语言是由字符串组成的集合，每个字符串是由有限字母表中的符号组成的有限序列。对于语法分析而言，字符串是源程序，符号是词法单词，字母表是词法分析器返回的单词类型集合。

一个上下文无关文法描述一种语言。文法有如下形式的产生式(production)集合: 

$$
symbol \rightarrow symbol \; symbol \cdots synbol
$$

其中，产生式的右部有0至多个符号。每一个符号或者是终结符（terminal）——来自该语言字符串字母表中的单词，或者是非终结符（nonterminal）——出现在某个产生式的左部。单词决不会出现在产生式的左部。最后，有一个区别对待的非终结符，称为文法的开始符号（start symbol）。

文法\ref{grammar:1}是一个直线式程序的文法例子。它的开始符号是$S$（当未明确给出开始符号时，约定第一个产生式左部的非终结符为开始符号）。此例中的终结符为:

id print num . + ( ) := ;

非终结符是$S$、$E$和$L$。属于这个文法语言的一个句子为：

id := num; id := id + (id := num + num, id)

与它对应的源程序(在词法分析之前的)可以是:

a := 7;

b := c + (d := 5 + 6, d)

\section{预测分析}

\section{LR分析}

\section{使用分析器的生成器}

\section{错误恢复}

\section{程序设计：语法分析}

\section{推荐阅读}

\section{习题}

\chapter{抽象语法}

\section{语义动作}

\section{抽象语法分析树}

\chapter{语义分析}

\section{符号表}

\section{Tiger编译器的绑定}

\section{表达式的类型检查}

\section{声明}

\end{document}